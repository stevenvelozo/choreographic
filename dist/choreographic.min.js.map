{"version":3,"sources":["node_modules/browser-pack/_prelude.js","node_modules/async/asyncify.js","choreographic.min.js","node_modules/async/eachLimit.js","node_modules/async/internal/asyncEachOfLimit.js","node_modules/async/internal/awaitify.js","node_modules/async/internal/breakLoop.js","node_modules/async/internal/eachOfLimit.js","node_modules/async/internal/getIterator.js","node_modules/async/internal/initialParams.js","node_modules/async/internal/isArrayLike.js","node_modules/async/internal/iterator.js","node_modules/async/internal/once.js","node_modules/async/internal/onlyOnce.js","node_modules/async/internal/setImmediate.js","node_modules/async/internal/withoutIndex.js","node_modules/async/internal/wrapAsync.js","node_modules/async/waterfall.js","node_modules/fable-log/source/Fable-Log-BaseLogger.js","node_modules/fable-log/source/Fable-Log-DefaultProviders-Web.js","node_modules/fable-log/source/Fable-Log-DefaultStreams.json","node_modules/fable-log/source/Fable-Log-Logger-Console.js","node_modules/fable-log/source/Fable-Log.js","node_modules/fable-settings/source/Fable-Settings-Default.json","node_modules/fable-settings/source/Fable-Settings-TemplateProcessor.js","node_modules/fable-settings/source/Fable-Settings.js","node_modules/fable-uuid/source/Fable-UUID-Random-Browser.js","node_modules/fable-uuid/source/Fable-UUID.js","node_modules/fable/source/Fable-Utility-Template.js","node_modules/fable/source/Fable-Utility.js","node_modules/fable/source/Fable.js","node_modules/precedent/source/Precedent.js","node_modules/precedent/source/StringParser.js","node_modules/precedent/source/WordTree.js","node_modules/process/browser.js","node_modules/timers-browserify/main.js","source/Choreographic-Browser-Shim.js","source/Choreographic.js"],"names":["f","exports","module","define","amd","window","global","self","this","Choreographic","r","e","n","t","o","i","c","require","u","a","Error","code","p","call","length","Object","defineProperty","value","default","func","_wrapAsync","isAsync","args","callback","pop","handlePromise","apply","_initialParams2","result","then","_interopRequireDefault","_setImmediate2","obj","__esModule","promise","invokeCallback","err","message","error","_eachOfLimit2","_withoutIndex2","_wrapAsync2","_awaitify2","coll","limit","iteratee","generator","done","canceled","awaiting","running","idx","replenish","next","iterDone","iterateeCallback","catch","handleError","_breakLoop2","_breakLoop","asyncFn","arity","Promise","resolve","reject","cbArgs","_once2","_iterator2","_onlyOnce2","_asyncEachOfLimit2","RangeError","isAsyncGenerator","isAsyncIterable","Symbol","asyncIterator","nextElem","looping","elem","key","iterator","fn","_isArrayLike2","len","createArrayIterator","_getIterator2","item","createES2015Iterator","okeys","keys","wrapper","callFn","assign","process","setImmediate","fallback","wrap","_defer","hasQueueMicrotask","queueMicrotask","hasSetImmediate","hasNextTick","nextTick","setTimeout","defer","_process","timers","index","undefined","_asyncify","_asyncify2","toStringTag","tasks","Array","isArray","taskIndex","nextTask","task","constructor","pLogStreamSettings","pFableLog","_Settings","loggerUUID","generateInsecureUUID","levels","tmpDate","Date","getTime","replace","pCharacter","tmpRandomData","Math","random","floor","toString","initialize","trace","pLogText","pLogObject","write","debug","info","warn","fatal","pLogLevel","getDefaultProviders","tmpDefaultProviders","console","loggertype","streamtype","level","libBaseLogger","super","_ShowTimeStamps","hasOwnProperty","showtimestamps","_FormattedTimeStamps","formattedtimestamps","_ContextMessage","Context","Product","_OutputLogLinesToConsole","outputloglinestoconsole","_OutputObjectsToConsole","outputobjectstoconsole","prefixCache","pLevel","pObject","tmpTimeStamp","toISOString","tmpLogLine","log","JSON","stringify","FableLog","pFableSettings","pFable","tmpSettings","_Providers","_StreamDefinitions","LogStreams","logStreams","logProviders","activeLogStreams","logStreamsTrace","logStreamsDebug","logStreamsInfo","logStreamsWarn","logStreamsError","logStreamsFatal","datumDecorator","pDatum","uuid","addLogger","pLogger","push","setDatumDecorator","fDatumDecorator","pMessage","tmpDecoratedDatum","tmpStreamDefinition","logTime","tmpMessage","tmpTime","getTimeStamp","getTimeDelta","pTimeStamp","logTimeDelta","pTimeDelta","tmpEndTime","logTimeDeltaHuman","tmpMs","parseInt","tmpSeconds","tmpMinutes","tmpHours","logTimeDeltaRelative","pStartTime","logTimeDeltaRelativeHuman","new","pSettings","LogProviderBase","ProductVersion","ConfigFile","pDependencies","templateProcessor","precedent","addPattern","pTemplateValue","tmpTemplateValue","trim","tmpSeparatorIndex","indexOf","tmpDefaultValue","substring","tmpEnvironmentVariableName","env","parseSetting","pString","parseString","libPrecedent","libFableSettingsTemplateProcessor","FableSettings","dependencies","settingsTemplateProcessor","_configureEnvTemplating","buildDefaultSettings","merge","base","parse","DefaultConfigFile","pException","settings","_PerformEnvTemplating","NoEnvReplacement","_resolveEnv","tmpKey","_isObject","_deepMergeObjects","toObject","fromObject","forEach","fromValue","toValue","pSettingsFrom","pSettingsTo","tmpSettingsFrom","tmpSettingsTo","tmpSettingsFromCopy","fill","getRandomValues","crypto","bind","msCrypto","generateWhatWGBytes","tmpBuffer","Uint8Array","generateRandomBytes","tmpValue","generate","libRandomByteGenerator","FableUUID","_UUIDModeRandom","UUIDModeRandom","_UUIDLength","UUIDLength","_UUIDRandomDictionary","UUIDDictionary","randomByteGenerator","_HexLookup","substr","bytesToUUID","pBuffer","join","generateUUIDv4","tmpRandomBytes","generateRandom","tmpUUID","charAt","getUUID","pTemplateText","fable","Matchers","Evaluate","Interpolate","Escaper","Unescaper","GuaranteedNonMatch","templateEscapes","u2028","u2029","renderFunction","extend","pDestinationObject","pSourceObjects","renderTemplate","pData","templateFunction","buildTemplateFunction","TemplateSource","pMatch","pCode","decodeURIComponent","Function","TemplateSourceCompiled","libFableUtilityTemplate","libAsyncWaterfall","libAsyncEachLimit","waterfall","eachLimit","template","chunk","pInput","pChunkSize","pChunkCache","tmpInputArray","tmpChunkSize","tmpChunkCache","splice","libFableSettings","libFableUUID","libFableLog","libFableUtility","Fable","settingsManager","libUUID","Utility","Dependencies","libWordTree","libStringParser","WordTree","StringParser","ParseTree","pPatternStart","pPatternEnd","pParser","newParserState","pParseTree","Output","OutputBuffer","Pattern","PatternMatch","PatternMatchOutputBuffer","assignNode","pNode","pParserState","appendOutputBuffer","flushOutputBuffer","checkPatternEnd","PatternEnd","PatternStart","Parse","parseCharacter","tmpParserState","addChild","pTree","pPattern","pIndex","tmpLeaf","cachedSetTimeout","cachedClearTimeout","defaultSetTimout","defaultClearTimeout","runTimeout","fun","clearTimeout","currentQueue","queue","draining","queueIndex","cleanUpNextTick","concat","drainQueue","timeout","run","marker","runClearTimeout","Item","array","noop","arguments","prototype","title","browser","argv","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","name","binding","cwd","chdir","dir","umask","clearImmediate","slice","immediateIds","nextImmediateId","Timeout","id","clearFn","_id","_clearFn","setInterval","clearInterval","close","unref","ref","enroll","msecs","_idleTimeoutId","_idleTimeout","unenroll","_unrefActive","active","_onTimeout","libChoreographic","libFS","pConfiguration","_InitialConfiguration","_InitialConfigurationFile","_Dependencies","fs","loadInitialConfigurationFile","timeStamps","progressTrackers","initializeSettingsObject","initializeRunSpecificData","pConfigurationFile","pConfigFileLoadException","App","_ERROR_App","Hash","DataRoot","existsSync","mkdirSync","RunTimeStart","formatDateString","pDateValue","RunID","getFullYear","getMonth","getDate","getHours","getMinutes","getSeconds","getMilliseconds","DataFolder","path","createTimeStamp","pTimeStampHash","tmpTimeStampHash","tmpOperationTime","createProgressTracker","pTotalOperations","pProgressTrackerHash","tmpProgressTrackerHash","tmpTotalOperations","tmpProgressTracker","StartTime","EndTime","CurrentTime","PercentComplete","AverageOperationTime","EstimatedCompletionTime","TotalCount","CurrentCount","solveProgressTrackerStatus","updateProgressTrackerStatus","pCurrentOperations","tmpCurrentOperations","isNaN","incrementProgressTrackerStatus","pIncrementSize","tmpIncrementSize","setProgressTrackerEndTime","printProgressTrackerStatus","toFixed","logMemoryResourcesUsed","tmpResourcesUsed","memoryUsage","heapUsed","round","writeFileToRunDataFolderFromObjectSync","pFileName","writeFileSync","writeFileToRunDataFolderSync","pFileContent","writeTextFileFromArray","pFileArray","tmpOutCSVFile","appendFileSync","enumerateObjectProperties","fProcessFunction","fEnumerationComplete","pParallelOperations","tmpParallelOperations","tmpObjectPropertyKeys","tmpfEnumerationComplete","libAsync","fOperationComplete","enumerateArrayEntries","pArray","tmpEntry"],"mappings":"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","file":"choreographic.min.js","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = asyncify;\n\nvar _initialParams = require('./internal/initialParams.js');\n\nvar _initialParams2 = _interopRequireDefault(_initialParams);\n\nvar _setImmediate = require('./internal/setImmediate.js');\n\nvar _setImmediate2 = _interopRequireDefault(_setImmediate);\n\nvar _wrapAsync = require('./internal/wrapAsync.js');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Take a sync function and make it async, passing its return value to a\n * callback. This is useful for plugging sync functions into a waterfall,\n * series, or other async functions. Any arguments passed to the generated\n * function will be passed to the wrapped function (except for the final\n * callback argument). Errors thrown will be passed to the callback.\n *\n * If the function passed to `asyncify` returns a Promise, that promises's\n * resolved/rejected state will be used to call the callback, rather than simply\n * the synchronous return value.\n *\n * This also means you can asyncify ES2017 `async` functions.\n *\n * @name asyncify\n * @static\n * @memberOf module:Utils\n * @method\n * @alias wrapSync\n * @category Util\n * @param {Function} func - The synchronous function, or Promise-returning\n * function to convert to an {@link AsyncFunction}.\n * @returns {AsyncFunction} An asynchronous wrapper of the `func`. To be\n * invoked with `(args..., callback)`.\n * @example\n *\n * // passing a regular synchronous function\n * async.waterfall([\n *     async.apply(fs.readFile, filename, \"utf8\"),\n *     async.asyncify(JSON.parse),\n *     function (data, next) {\n *         // data is the result of parsing the text.\n *         // If there was a parsing error, it would have been caught.\n *     }\n * ], callback);\n *\n * // passing a function returning a promise\n * async.waterfall([\n *     async.apply(fs.readFile, filename, \"utf8\"),\n *     async.asyncify(function (contents) {\n *         return db.model.create(contents);\n *     }),\n *     function (model, next) {\n *         // `model` is the instantiated model object.\n *         // If there was an error, this function would be skipped.\n *     }\n * ], callback);\n *\n * // es2017 example, though `asyncify` is not needed if your JS environment\n * // supports async functions out of the box\n * var q = async.queue(async.asyncify(async function(file) {\n *     var intermediateStep = await processFile(file);\n *     return await somePromise(intermediateStep)\n * }));\n *\n * q.push(files);\n */\nfunction asyncify(func) {\n    if ((0, _wrapAsync.isAsync)(func)) {\n        return function (...args /*, callback*/) {\n            const callback = args.pop();\n            const promise = func.apply(this, args);\n            return handlePromise(promise, callback);\n        };\n    }\n\n    return (0, _initialParams2.default)(function (args, callback) {\n        var result;\n        try {\n            result = func.apply(this, args);\n        } catch (e) {\n            return callback(e);\n        }\n        // if result is Promise object\n        if (result && typeof result.then === 'function') {\n            return handlePromise(result, callback);\n        } else {\n            callback(null, result);\n        }\n    });\n}\n\nfunction handlePromise(promise, callback) {\n    return promise.then(value => {\n        invokeCallback(callback, null, value);\n    }, err => {\n        invokeCallback(callback, err && err.message ? err : new Error(err));\n    });\n}\n\nfunction invokeCallback(callback, error, value) {\n    try {\n        callback(error, value);\n    } catch (err) {\n        (0, _setImmediate2.default)(e => {\n            throw e;\n        }, err);\n    }\n}\nmodule.exports = exports['default'];","(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.Choreographic = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = asyncify;\n\nvar _initialParams = require('./internal/initialParams.js');\n\nvar _initialParams2 = _interopRequireDefault(_initialParams);\n\nvar _setImmediate = require('./internal/setImmediate.js');\n\nvar _setImmediate2 = _interopRequireDefault(_setImmediate);\n\nvar _wrapAsync = require('./internal/wrapAsync.js');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Take a sync function and make it async, passing its return value to a\n * callback. This is useful for plugging sync functions into a waterfall,\n * series, or other async functions. Any arguments passed to the generated\n * function will be passed to the wrapped function (except for the final\n * callback argument). Errors thrown will be passed to the callback.\n *\n * If the function passed to `asyncify` returns a Promise, that promises's\n * resolved/rejected state will be used to call the callback, rather than simply\n * the synchronous return value.\n *\n * This also means you can asyncify ES2017 `async` functions.\n *\n * @name asyncify\n * @static\n * @memberOf module:Utils\n * @method\n * @alias wrapSync\n * @category Util\n * @param {Function} func - The synchronous function, or Promise-returning\n * function to convert to an {@link AsyncFunction}.\n * @returns {AsyncFunction} An asynchronous wrapper of the `func`. To be\n * invoked with `(args..., callback)`.\n * @example\n *\n * // passing a regular synchronous function\n * async.waterfall([\n *     async.apply(fs.readFile, filename, \"utf8\"),\n *     async.asyncify(JSON.parse),\n *     function (data, next) {\n *         // data is the result of parsing the text.\n *         // If there was a parsing error, it would have been caught.\n *     }\n * ], callback);\n *\n * // passing a function returning a promise\n * async.waterfall([\n *     async.apply(fs.readFile, filename, \"utf8\"),\n *     async.asyncify(function (contents) {\n *         return db.model.create(contents);\n *     }),\n *     function (model, next) {\n *         // `model` is the instantiated model object.\n *         // If there was an error, this function would be skipped.\n *     }\n * ], callback);\n *\n * // es2017 example, though `asyncify` is not needed if your JS environment\n * // supports async functions out of the box\n * var q = async.queue(async.asyncify(async function(file) {\n *     var intermediateStep = await processFile(file);\n *     return await somePromise(intermediateStep)\n * }));\n *\n * q.push(files);\n */\nfunction asyncify(func) {\n    if ((0, _wrapAsync.isAsync)(func)) {\n        return function (...args /*, callback*/) {\n            const callback = args.pop();\n            const promise = func.apply(this, args);\n            return handlePromise(promise, callback);\n        };\n    }\n\n    return (0, _initialParams2.default)(function (args, callback) {\n        var result;\n        try {\n            result = func.apply(this, args);\n        } catch (e) {\n            return callback(e);\n        }\n        // if result is Promise object\n        if (result && typeof result.then === 'function') {\n            return handlePromise(result, callback);\n        } else {\n            callback(null, result);\n        }\n    });\n}\n\nfunction handlePromise(promise, callback) {\n    return promise.then(value => {\n        invokeCallback(callback, null, value);\n    }, err => {\n        invokeCallback(callback, err && err.message ? err : new Error(err));\n    });\n}\n\nfunction invokeCallback(callback, error, value) {\n    try {\n        callback(error, value);\n    } catch (err) {\n        (0, _setImmediate2.default)(e => {\n            throw e;\n        }, err);\n    }\n}\nmodule.exports = exports['default'];\n},{\"./internal/initialParams.js\":8,\"./internal/setImmediate.js\":13,\"./internal/wrapAsync.js\":15}],2:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _eachOfLimit = require('./internal/eachOfLimit.js');\n\nvar _eachOfLimit2 = _interopRequireDefault(_eachOfLimit);\n\nvar _withoutIndex = require('./internal/withoutIndex.js');\n\nvar _withoutIndex2 = _interopRequireDefault(_withoutIndex);\n\nvar _wrapAsync = require('./internal/wrapAsync.js');\n\nvar _wrapAsync2 = _interopRequireDefault(_wrapAsync);\n\nvar _awaitify = require('./internal/awaitify.js');\n\nvar _awaitify2 = _interopRequireDefault(_awaitify);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * The same as [`each`]{@link module:Collections.each} but runs a maximum of `limit` async operations at a time.\n *\n * @name eachLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.each]{@link module:Collections.each}\n * @alias forEachLimit\n * @category Collection\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - An async function to apply to each item in\n * `coll`.\n * The array index is not passed to the iteratee.\n * If you need the index, use `eachOfLimit`.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called when all\n * `iteratee` functions have finished, or an error occurs. Invoked with (err).\n * @returns {Promise} a promise, if a callback is omitted\n */\nfunction eachLimit(coll, limit, iteratee, callback) {\n  return (0, _eachOfLimit2.default)(limit)(coll, (0, _withoutIndex2.default)((0, _wrapAsync2.default)(iteratee)), callback);\n}\nexports.default = (0, _awaitify2.default)(eachLimit, 4);\nmodule.exports = exports['default'];\n},{\"./internal/awaitify.js\":4,\"./internal/eachOfLimit.js\":6,\"./internal/withoutIndex.js\":14,\"./internal/wrapAsync.js\":15}],3:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = asyncEachOfLimit;\n\nvar _breakLoop = require('./breakLoop.js');\n\nvar _breakLoop2 = _interopRequireDefault(_breakLoop);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// for async generators\nfunction asyncEachOfLimit(generator, limit, iteratee, callback) {\n    let done = false;\n    let canceled = false;\n    let awaiting = false;\n    let running = 0;\n    let idx = 0;\n\n    function replenish() {\n        //console.log('replenish')\n        if (running >= limit || awaiting || done) return;\n        //console.log('replenish awaiting')\n        awaiting = true;\n        generator.next().then(({ value, done: iterDone }) => {\n            //console.log('got value', value)\n            if (canceled || done) return;\n            awaiting = false;\n            if (iterDone) {\n                done = true;\n                if (running <= 0) {\n                    //console.log('done nextCb')\n                    callback(null);\n                }\n                return;\n            }\n            running++;\n            iteratee(value, idx, iterateeCallback);\n            idx++;\n            replenish();\n        }).catch(handleError);\n    }\n\n    function iterateeCallback(err, result) {\n        //console.log('iterateeCallback')\n        running -= 1;\n        if (canceled) return;\n        if (err) return handleError(err);\n\n        if (err === false) {\n            done = true;\n            canceled = true;\n            return;\n        }\n\n        if (result === _breakLoop2.default || done && running <= 0) {\n            done = true;\n            //console.log('done iterCb')\n            return callback(null);\n        }\n        replenish();\n    }\n\n    function handleError(err) {\n        if (canceled) return;\n        awaiting = false;\n        done = true;\n        callback(err);\n    }\n\n    replenish();\n}\nmodule.exports = exports['default'];\n},{\"./breakLoop.js\":5}],4:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = awaitify;\n// conditionally promisify a function.\n// only return a promise if a callback is omitted\nfunction awaitify(asyncFn, arity = asyncFn.length) {\n    if (!arity) throw new Error('arity is undefined');\n    function awaitable(...args) {\n        if (typeof args[arity - 1] === 'function') {\n            return asyncFn.apply(this, args);\n        }\n\n        return new Promise((resolve, reject) => {\n            args[arity - 1] = (err, ...cbArgs) => {\n                if (err) return reject(err);\n                resolve(cbArgs.length > 1 ? cbArgs : cbArgs[0]);\n            };\n            asyncFn.apply(this, args);\n        });\n    }\n\n    return awaitable;\n}\nmodule.exports = exports['default'];\n},{}],5:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n// A temporary value used to identify if the loop should be broken.\n// See #1064, #1293\nconst breakLoop = {};\nexports.default = breakLoop;\nmodule.exports = exports[\"default\"];\n},{}],6:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _once = require('./once.js');\n\nvar _once2 = _interopRequireDefault(_once);\n\nvar _iterator = require('./iterator.js');\n\nvar _iterator2 = _interopRequireDefault(_iterator);\n\nvar _onlyOnce = require('./onlyOnce.js');\n\nvar _onlyOnce2 = _interopRequireDefault(_onlyOnce);\n\nvar _wrapAsync = require('./wrapAsync.js');\n\nvar _asyncEachOfLimit = require('./asyncEachOfLimit.js');\n\nvar _asyncEachOfLimit2 = _interopRequireDefault(_asyncEachOfLimit);\n\nvar _breakLoop = require('./breakLoop.js');\n\nvar _breakLoop2 = _interopRequireDefault(_breakLoop);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = limit => {\n    return (obj, iteratee, callback) => {\n        callback = (0, _once2.default)(callback);\n        if (limit <= 0) {\n            throw new RangeError('concurrency limit cannot be less than 1');\n        }\n        if (!obj) {\n            return callback(null);\n        }\n        if ((0, _wrapAsync.isAsyncGenerator)(obj)) {\n            return (0, _asyncEachOfLimit2.default)(obj, limit, iteratee, callback);\n        }\n        if ((0, _wrapAsync.isAsyncIterable)(obj)) {\n            return (0, _asyncEachOfLimit2.default)(obj[Symbol.asyncIterator](), limit, iteratee, callback);\n        }\n        var nextElem = (0, _iterator2.default)(obj);\n        var done = false;\n        var canceled = false;\n        var running = 0;\n        var looping = false;\n\n        function iterateeCallback(err, value) {\n            if (canceled) return;\n            running -= 1;\n            if (err) {\n                done = true;\n                callback(err);\n            } else if (err === false) {\n                done = true;\n                canceled = true;\n            } else if (value === _breakLoop2.default || done && running <= 0) {\n                done = true;\n                return callback(null);\n            } else if (!looping) {\n                replenish();\n            }\n        }\n\n        function replenish() {\n            looping = true;\n            while (running < limit && !done) {\n                var elem = nextElem();\n                if (elem === null) {\n                    done = true;\n                    if (running <= 0) {\n                        callback(null);\n                    }\n                    return;\n                }\n                running += 1;\n                iteratee(elem.value, elem.key, (0, _onlyOnce2.default)(iterateeCallback));\n            }\n            looping = false;\n        }\n\n        replenish();\n    };\n};\n\nmodule.exports = exports['default'];\n},{\"./asyncEachOfLimit.js\":3,\"./breakLoop.js\":5,\"./iterator.js\":10,\"./once.js\":11,\"./onlyOnce.js\":12,\"./wrapAsync.js\":15}],7:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nexports.default = function (coll) {\n    return coll[Symbol.iterator] && coll[Symbol.iterator]();\n};\n\nmodule.exports = exports[\"default\"];\n},{}],8:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nexports.default = function (fn) {\n    return function (...args /*, callback*/) {\n        var callback = args.pop();\n        return fn.call(this, args, callback);\n    };\n};\n\nmodule.exports = exports[\"default\"];\n},{}],9:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = isArrayLike;\nfunction isArrayLike(value) {\n    return value && typeof value.length === 'number' && value.length >= 0 && value.length % 1 === 0;\n}\nmodule.exports = exports['default'];\n},{}],10:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = createIterator;\n\nvar _isArrayLike = require('./isArrayLike.js');\n\nvar _isArrayLike2 = _interopRequireDefault(_isArrayLike);\n\nvar _getIterator = require('./getIterator.js');\n\nvar _getIterator2 = _interopRequireDefault(_getIterator);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction createArrayIterator(coll) {\n    var i = -1;\n    var len = coll.length;\n    return function next() {\n        return ++i < len ? { value: coll[i], key: i } : null;\n    };\n}\n\nfunction createES2015Iterator(iterator) {\n    var i = -1;\n    return function next() {\n        var item = iterator.next();\n        if (item.done) return null;\n        i++;\n        return { value: item.value, key: i };\n    };\n}\n\nfunction createObjectIterator(obj) {\n    var okeys = obj ? Object.keys(obj) : [];\n    var i = -1;\n    var len = okeys.length;\n    return function next() {\n        var key = okeys[++i];\n        if (key === '__proto__') {\n            return next();\n        }\n        return i < len ? { value: obj[key], key } : null;\n    };\n}\n\nfunction createIterator(coll) {\n    if ((0, _isArrayLike2.default)(coll)) {\n        return createArrayIterator(coll);\n    }\n\n    var iterator = (0, _getIterator2.default)(coll);\n    return iterator ? createES2015Iterator(iterator) : createObjectIterator(coll);\n}\nmodule.exports = exports['default'];\n},{\"./getIterator.js\":7,\"./isArrayLike.js\":9}],11:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = once;\nfunction once(fn) {\n    function wrapper(...args) {\n        if (fn === null) return;\n        var callFn = fn;\n        fn = null;\n        callFn.apply(this, args);\n    }\n    Object.assign(wrapper, fn);\n    return wrapper;\n}\nmodule.exports = exports[\"default\"];\n},{}],12:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = onlyOnce;\nfunction onlyOnce(fn) {\n    return function (...args) {\n        if (fn === null) throw new Error(\"Callback was already called.\");\n        var callFn = fn;\n        fn = null;\n        callFn.apply(this, args);\n    };\n}\nmodule.exports = exports[\"default\"];\n},{}],13:[function(require,module,exports){\n(function (process,setImmediate){(function (){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.fallback = fallback;\nexports.wrap = wrap;\n/* istanbul ignore file */\n\nvar hasQueueMicrotask = exports.hasQueueMicrotask = typeof queueMicrotask === 'function' && queueMicrotask;\nvar hasSetImmediate = exports.hasSetImmediate = typeof setImmediate === 'function' && setImmediate;\nvar hasNextTick = exports.hasNextTick = typeof process === 'object' && typeof process.nextTick === 'function';\n\nfunction fallback(fn) {\n    setTimeout(fn, 0);\n}\n\nfunction wrap(defer) {\n    return (fn, ...args) => defer(() => fn(...args));\n}\n\nvar _defer;\n\nif (hasQueueMicrotask) {\n    _defer = queueMicrotask;\n} else if (hasSetImmediate) {\n    _defer = setImmediate;\n} else if (hasNextTick) {\n    _defer = process.nextTick;\n} else {\n    _defer = fallback;\n}\n\nexports.default = wrap(_defer);\n}).call(this)}).call(this,require('_process'),require(\"timers\").setImmediate)\n\n},{\"_process\":34,\"timers\":35}],14:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = _withoutIndex;\nfunction _withoutIndex(iteratee) {\n    return (value, index, callback) => iteratee(value, callback);\n}\nmodule.exports = exports[\"default\"];\n},{}],15:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.isAsyncIterable = exports.isAsyncGenerator = exports.isAsync = undefined;\n\nvar _asyncify = require('../asyncify.js');\n\nvar _asyncify2 = _interopRequireDefault(_asyncify);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction isAsync(fn) {\n    return fn[Symbol.toStringTag] === 'AsyncFunction';\n}\n\nfunction isAsyncGenerator(fn) {\n    return fn[Symbol.toStringTag] === 'AsyncGenerator';\n}\n\nfunction isAsyncIterable(obj) {\n    return typeof obj[Symbol.asyncIterator] === 'function';\n}\n\nfunction wrapAsync(asyncFn) {\n    if (typeof asyncFn !== 'function') throw new Error('expected a function');\n    return isAsync(asyncFn) ? (0, _asyncify2.default)(asyncFn) : asyncFn;\n}\n\nexports.default = wrapAsync;\nexports.isAsync = isAsync;\nexports.isAsyncGenerator = isAsyncGenerator;\nexports.isAsyncIterable = isAsyncIterable;\n},{\"../asyncify.js\":1}],16:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _once = require('./internal/once.js');\n\nvar _once2 = _interopRequireDefault(_once);\n\nvar _onlyOnce = require('./internal/onlyOnce.js');\n\nvar _onlyOnce2 = _interopRequireDefault(_onlyOnce);\n\nvar _wrapAsync = require('./internal/wrapAsync.js');\n\nvar _wrapAsync2 = _interopRequireDefault(_wrapAsync);\n\nvar _awaitify = require('./internal/awaitify.js');\n\nvar _awaitify2 = _interopRequireDefault(_awaitify);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Runs the `tasks` array of functions in series, each passing their results to\n * the next in the array. However, if any of the `tasks` pass an error to their\n * own callback, the next function is not executed, and the main `callback` is\n * immediately called with the error.\n *\n * @name waterfall\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Array} tasks - An array of [async functions]{@link AsyncFunction}\n * to run.\n * Each function should complete with any number of `result` values.\n * The `result` values will be passed as arguments, in order, to the next task.\n * @param {Function} [callback] - An optional callback to run once all the\n * functions have completed. This will be passed the results of the last task's\n * callback. Invoked with (err, [results]).\n * @returns {Promise} a promise, if a callback is omitted\n * @example\n *\n * async.waterfall([\n *     function(callback) {\n *         callback(null, 'one', 'two');\n *     },\n *     function(arg1, arg2, callback) {\n *         // arg1 now equals 'one' and arg2 now equals 'two'\n *         callback(null, 'three');\n *     },\n *     function(arg1, callback) {\n *         // arg1 now equals 'three'\n *         callback(null, 'done');\n *     }\n * ], function (err, result) {\n *     // result now equals 'done'\n * });\n *\n * // Or, with named functions:\n * async.waterfall([\n *     myFirstFunction,\n *     mySecondFunction,\n *     myLastFunction,\n * ], function (err, result) {\n *     // result now equals 'done'\n * });\n * function myFirstFunction(callback) {\n *     callback(null, 'one', 'two');\n * }\n * function mySecondFunction(arg1, arg2, callback) {\n *     // arg1 now equals 'one' and arg2 now equals 'two'\n *     callback(null, 'three');\n * }\n * function myLastFunction(arg1, callback) {\n *     // arg1 now equals 'three'\n *     callback(null, 'done');\n * }\n */\nfunction waterfall(tasks, callback) {\n    callback = (0, _once2.default)(callback);\n    if (!Array.isArray(tasks)) return callback(new Error('First argument to waterfall must be an array of functions'));\n    if (!tasks.length) return callback();\n    var taskIndex = 0;\n\n    function nextTask(args) {\n        var task = (0, _wrapAsync2.default)(tasks[taskIndex++]);\n        task(...args, (0, _onlyOnce2.default)(next));\n    }\n\n    function next(err, ...args) {\n        if (err === false) return;\n        if (err || taskIndex === tasks.length) {\n            return callback(err, ...args);\n        }\n        nextTask(args);\n    }\n\n    nextTask([]);\n}\n\nexports.default = (0, _awaitify2.default)(waterfall);\nmodule.exports = exports['default'];\n},{\"./internal/awaitify.js\":4,\"./internal/once.js\":11,\"./internal/onlyOnce.js\":12,\"./internal/wrapAsync.js\":15}],17:[function(require,module,exports){\n\n},{}],18:[function(require,module,exports){\n/**\n* Base Logger Class\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n*/\n\nclass BaseLogger\n{\n\tconstructor(pLogStreamSettings, pFableLog)\n\t{\n\t\t// This should not possibly be able to be instantiated without a settings object\n\t\tthis._Settings = (typeof(pLogStreamSettings) == 'object') ? pLogStreamSettings : {};\n\n\t\t// The base logger does nothing but associate a UUID with itself\n\t\t// We added this as the mechanism for tracking loggers to allow multiple simultaneous streams\n\t\t// to the same provider.\n\t\tthis.loggerUUID = this.generateInsecureUUID();\n\n\t\t// Eventually we can use this array to ompute which levels the provider allows.\n\t\t// For now it's just used to precompute some string concatenations.\n\t\tthis.levels = (\n\t\t\t[\n\t\t\t\t\"trace\",\n\t\t\t\t\"debug\",\n\t\t\t\t\"info\",\n\t\t\t\t\"warn\",\n\t\t\t\t\"error\",\n\t\t\t\t\"fatal\"\n\t\t\t]);\n\t}\n\n\t// This is meant to generate programmatically insecure UUIDs to identify loggers\n\tgenerateInsecureUUID()\n\t{\n\t\tlet tmpDate = new Date().getTime();\n\t\tlet tmpUUID = 'LOGSTREAM-xxxxxx-yxxxxx'.replace(/[xy]/g,\n\t\t\t\t(pCharacter) =>\n\t\t\t\t{\n\t\t\t\t\t// Funny algorithm from w3resource that is twister-ish without the deep math and security\n\t\t\t\t\t// ..but good enough for unique log stream identifiers\n\t\t\t\t\tlet tmpRandomData = (tmpDate + Math.random()*16)%16 | 0;\n\t\t\t\t\ttmpDate = Math.floor(tmpDate/16);\n\n\t\t\t\t\treturn (pCharacter =='x' ? tmpRandomData : (tmpRandomData&0x3|0x8)).toString(16);\n\t\t\t\t});\n\t\treturn tmpUUID;\n\t}\n\n\tinitialize()\n\t{\n\t\t// No operation.\n\t}\n\n\ttrace(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"trace\", pLogText, pLogObject);\n\t}\n\n\tdebug(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"debug\", pLogText, pLogObject);\n\t}\n\n\tinfo(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"info\", pLogText, pLogObject);\n\t}\n\n\twarn(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"warn\", pLogText, pLogObject);\n\t}\n\n\terror(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"error\", pLogText, pLogObject);\n\t}\n\n\tfatal(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"fatal\", pLogText, pLogObject);\n\t}\n\n\twrite(pLogLevel, pLogText, pLogObject)\n\t{\n\t\t// The base logger does nothing.\n\t\treturn true;\n\t}\n}\n\nmodule.exports = BaseLogger;\n\n},{}],19:[function(require,module,exports){\n/**\n* Default Logger Provider Function\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n*/\n\n// Return the providers that are available without extensions loaded\ngetDefaultProviders = () =>\n{\n\tlet tmpDefaultProviders = {};\n\n\ttmpDefaultProviders.console = require('./Fable-Log-Logger-Console.js');\n\n\ttmpDefaultProviders.default = tmpDefaultProviders.console;\n\n\treturn tmpDefaultProviders;\n}\n\nmodule.exports = getDefaultProviders();\n},{\"./Fable-Log-Logger-Console.js\":21}],20:[function(require,module,exports){\nmodule.exports=[\n    {\n        \"loggertype\": \"console\",\n        \"streamtype\": \"console\",\n        \"level\": \"trace\"\n    }\n]\n},{}],21:[function(require,module,exports){\nlet libBaseLogger = require('./Fable-Log-BaseLogger.js');\n\nclass ConsoleLogger extends libBaseLogger\n{\n\tconstructor(pLogStreamSettings, pFableLog)\n\t{\n\t\tsuper(pLogStreamSettings);\n\n\t\tthis._ShowTimeStamps = this._Settings.hasOwnProperty('showtimestamps') ? (this._Settings.showtimestamps == true) : false;\n\t\tthis._FormattedTimeStamps = this._Settings.hasOwnProperty('formattedtimestamps') ? (this._Settings.formattedtimestamps == true) : false;\n\n\t\tthis._ContextMessage = this._Settings.hasOwnProperty('Context') ? `(${this._Settings.Context})` : \n\t\t\t\t\t\t\t\tpFableLog._Settings.hasOwnProperty('Product') ? `(${pFableLog._Settings.Product})` :\n\t\t\t\t\t\t\t\t'Unnamed_Log_Context';\n\n\t\t// Allow the user to decide what gets output to the console\n\t\tthis._OutputLogLinesToConsole = this._Settings.hasOwnProperty('outputloglinestoconsole') ? this._Settings.outputloglinestoconsole : true;\n\t\tthis._OutputObjectsToConsole = this._Settings.hasOwnProperty('outputobjectstoconsole') ? this._Settings.outputobjectstoconsole : true;\n\n\t\t// Precompute the prefix for each level\n\t\tthis.prefixCache = {};\n\t\tfor (let i = 0; i <= this.levels.length; i++)\n\t\t{\n\t\t\tthis.prefixCache[this.levels[i]] = `[${this.levels[i]}] ${this._ContextMessage}: `;\n\n\t\t\tif (this._ShowTimeStamps)\n\t\t\t{\n\t\t\t\t// If there is a timestamp we need a to prepend space before the prefixcache string, since the timestamp comes first\n\t\t\t\tthis.prefixCache[this.levels[i]] = ' '+this.prefixCache[this.levels[i]];\n\t\t\t}\n\t\t}\n\t}\n\n\twrite(pLevel, pLogText, pObject)\n\t{\n\t\tlet tmpTimeStamp = '';\n\t\tif (this._ShowTimeStamps && this._FormattedTimeStamps)\n\t\t{\n\t\t\ttmpTimeStamp = (new Date()).toISOString();\n\t\t}\n\t\telse if (this._ShowTimeStamps)\n\t\t{\n\t\t\ttmpTimeStamp = +new Date();\n\t\t}\n\n\t\tlet tmpLogLine = `${tmpTimeStamp}${this.prefixCache[pLevel]}${pLogText}`;\n\n\t\tif (this._OutputLogLinesToConsole)\n\t\t{\n\t\t\tconsole.log(tmpLogLine);\n\t\t}\n\n\t\t// Write out the object on a separate line if it is passed in\n\t\tif (this._OutputObjectsToConsole && (typeof(pObject) !== 'undefined'))\n\t\t{\n\t\t\tconsole.log(JSON.stringify(pObject, null, 2));\n\t\t}\n\n\t\t// Provide an easy way to be overridden and be consistent\n\t\treturn tmpLogLine;\n\t}\n}\n\nmodule.exports = ConsoleLogger;\n},{\"./Fable-Log-BaseLogger.js\":18}],22:[function(require,module,exports){\n/**\n* Fable Logging Add-on\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n* @module Fable Logger\n*/\n\n/**\n* Fable Solution Log Wrapper Main Class\n*\n* @class FableLog\n* @constructor\n*/\nclass FableLog\n{\n\tconstructor(pFableSettings, pFable)\n\t{\n\t\tlet tmpSettings = (typeof(pFableSettings) === 'object') ? pFableSettings : {}\n\t\tthis._Settings = tmpSettings;\n\n\t\tthis._Providers = require('./Fable-Log-DefaultProviders-Node.js');\n\n\t\tthis._StreamDefinitions = (tmpSettings.hasOwnProperty('LogStreams')) ? tmpSettings.LogStreams : require('./Fable-Log-DefaultStreams.json');\n\n\t\tthis.logStreams = [];\n\n\t\t// This object gets decorated for one-time instantiated providers that\n\t\t//  have multiple outputs, such as bunyan.\n\t\tthis.logProviders = {};\n\n\t\t// A hash list of the GUIDs for each log stream, so they can't be added to the set more than one time\n\t\tthis.activeLogStreams = {};\n\n\t\tthis.logStreamsTrace = [];\n\t\tthis.logStreamsDebug = [];\n\t\tthis.logStreamsInfo = [];\n\t\tthis.logStreamsWarn = [];\n\t\tthis.logStreamsError = [];\n\t\tthis.logStreamsFatal = [];\n\n\t\tthis.datumDecorator = (pDatum) => pDatum;\n\n\t\tthis.uuid = (typeof(tmpSettings.Product) === 'string') ? tmpSettings.Product : 'Default';\n\t}\n\n\taddLogger(pLogger, pLevel)\n\t{\n\t\t// Bail out if we've already created one.\n\t\tif (this.activeLogStreams.hasOwnProperty(pLogger.loggerUUID))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\t// Add it to the streams and to the mutex\n\t\tthis.logStreams.push(pLogger);\n\t\tthis.activeLogStreams[pLogger.loggerUUID] = true;\n\n\t\t// Make sure a kosher level was passed in\n\t\tswitch (pLevel)\n\t\t{\n\t\t\tcase 'trace':\n\t\t\t\tthis.logStreamsTrace.push(pLogger);\n\t\t\tcase 'debug':\n\t\t\t\tthis.logStreamsDebug.push(pLogger);\n\t\t\tcase 'info':\n\t\t\t\tthis.logStreamsInfo.push(pLogger);\n\t\t\tcase 'warn':\n\t\t\t\tthis.logStreamsWarn.push(pLogger);\n\t\t\tcase 'error':\n\t\t\t\tthis.logStreamsError.push(pLogger);\n\t\t\tcase 'fatal':\n\t\t\t\tthis.logStreamsFatal.push(pLogger);\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tsetDatumDecorator(fDatumDecorator)\n\t{\n\t\tif (typeof(fDatumDecorator) === 'function')\n\t\t{\n\t\t\tthis.datumDecorator = fDatumDecorator;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.datumDecorator = (pDatum) => pDatum;\n\t\t}\n\t}\n\n\ttrace(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsTrace.length; i++)\n\t\t{\n\t\t\tthis.logStreamsTrace[i].trace(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\tdebug(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsDebug.length; i++)\n\t\t{\n\t\t\tthis.logStreamsDebug[i].debug(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\tinfo(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsInfo.length; i++)\n\t\t{\n\t\t\tthis.logStreamsInfo[i].info(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\twarn(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsWarn.length; i++)\n\t\t{\n\t\t\tthis.logStreamsWarn[i].warn(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\terror(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsError.length; i++)\n\t\t{\n\t\t\tthis.logStreamsError[i].error(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\tfatal(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsFatal.length; i++)\n\t\t{\n\t\t\tthis.logStreamsFatal[i].fatal(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\tinitialize()\n\t{\n\t\t// \"initialize\" each logger as defined in the logging parameters\n\t\tfor (let i = 0; i < this._StreamDefinitions.length; i++)\n\t\t{\n\t\t\tlet tmpStreamDefinition = Object.assign({loggertype:'default',streamtype:'console',level:'info'},this._StreamDefinitions[i]);\n\n\t\t\tif (!this._Providers.hasOwnProperty(tmpStreamDefinition.loggertype))\n\t\t\t{\n\t\t\t\tconsole.log(`Error initializing log stream: bad loggertype in stream definition ${JSON.stringify(tmpStreamDefinition)}`);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.addLogger(new this._Providers[tmpStreamDefinition.loggertype](tmpStreamDefinition, this), tmpStreamDefinition.level);\n\t\t\t}\n\t\t}\n\n\t\t// Now initialize each one.\n\t\tfor (let i = 0; i < this.logStreams.length; i++)\n\t\t{\n\t\t\tthis.logStreams[i].initialize();\n\t\t}\n\t}\n\n\tlogTime(pMessage, pDatum)\n\t{\n\t\tlet tmpMessage = (typeof(pMessage) !== 'undefined') ? pMessage : 'Time';\n\t\tlet tmpTime = new Date();\n\t\tthis.info(`${tmpMessage} ${tmpTime} (epoch ${+tmpTime})`, pDatum);\n\t}\n\n\t// Get a timestamp\n\tgetTimeStamp()\n\t{\n\t\treturn +new Date();\n\t}\n\n\tgetTimeDelta(pTimeStamp)\n\t{\n\t\tlet tmpEndTime = +new Date();\n\t\treturn tmpEndTime-pTimeStamp;\n\t}\n\n\t// Log the delta between a timestamp, and now with a message\n\tlogTimeDelta(pTimeDelta, pMessage, pDatum)\n\t{\n\t\tlet tmpMessage = (typeof(pMessage) !== 'undefined') ? pMessage : 'Time Measurement';\n\t\tlet tmpDatum = (typeof(pDatum) === 'object') ? pDatum : {};\n\n\t\tlet tmpEndTime = +new Date();\n\n\t\tthis.info(`${tmpMessage} logged at (epoch ${+tmpEndTime}) took (${pTimeDelta}ms)`, pDatum);\n\t}\n\n\tlogTimeDeltaHuman(pTimeDelta, pMessage, pDatum)\n\t{\n\t\tlet tmpMessage = (typeof(pMessage) !== 'undefined') ? pMessage : 'Time Measurement';\n\n\t\tlet tmpEndTime = +new Date();\n\n\t\tlet tmpMs = parseInt(pTimeDelta%1000);\n\t\tlet tmpSeconds = parseInt((pTimeDelta/1000)%60);\n\t\tlet tmpMinutes = parseInt((pTimeDelta/(1000*60))%60);\n\t\tlet tmpHours = parseInt(pTimeDelta/(1000*60*60));\n\n\t\ttmpMs = (tmpMs < 10) ? \"00\"+tmpMs : (tmpMs < 100) ? \"0\"+tmpMs : tmpMs;\n\t\ttmpSeconds = (tmpSeconds < 10) ? \"0\"+tmpSeconds : tmpSeconds;\n\t\ttmpMinutes = (tmpMinutes < 10) ? \"0\"+tmpMinutes : tmpMinutes;\n\t\ttmpHours = (tmpHours < 10) ? \"0\"+tmpHours : tmpHours;\n\n\t\tthis.info(`${tmpMessage} logged at (epoch ${+tmpEndTime}) took (${pTimeDelta}ms) or (${tmpHours}:${tmpMinutes}:${tmpSeconds}.${tmpMs})`, pDatum);\n\t}\n\n\tlogTimeDeltaRelative(pStartTime, pMessage, pDatum)\n\t{\n\t\tthis.logTimeDelta(this.getTimeDelta(pStartTime), pMessage, pDatum);\n\t}\n\n\tlogTimeDeltaRelativeHuman(pStartTime, pMessage, pDatum)\n\t{\n\t\tthis.logTimeDeltaHuman(this.getTimeDelta(pStartTime), pMessage, pDatum);\n\t}\n}\n\n// This is for backwards compatibility\nfunction autoConstruct(pSettings)\n{\n\treturn new FableLog(pSettings);\n}\n\n\nmodule.exports = FableLog;\nmodule.exports.new = autoConstruct;\nmodule.exports.LogProviderBase = require('./Fable-Log-BaseLogger.js');\n\n},{\"./Fable-Log-BaseLogger.js\":18,\"./Fable-Log-DefaultProviders-Node.js\":19,\"./Fable-Log-DefaultStreams.json\":20}],23:[function(require,module,exports){\nmodule.exports={\n\t\"Product\": \"ApplicationNameHere\",\n\t\"ProductVersion\": \"0.0.0\",\n\n\t\"ConfigFile\": false,\n\n\t\"LogStreams\":\n\t[\n\t\t{\n\t\t\t\"level\": \"trace\"\n\t\t}\n\t]\n}\n\n},{}],24:[function(require,module,exports){\n(function (process){(function (){\n/**\n* Fable Settings Template Processor\n*\n* This class allows environment variables to come in via templated expressions, and defaults to be set.\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n* @module Fable Settings\n*/\n\nclass FableSettingsTemplateProcessor\n{\n\tconstructor(pDependencies)\n\t{\n        // Use a no-dependencies templating engine to parse out environment variables\n\t\tthis.templateProcessor = new pDependencies.precedent();\n\n        // TODO: Make the environment variable wrap expression demarcation characters configurable?\n\t\tthis.templateProcessor.addPattern('${', '}',\n\t\t\t(pTemplateValue)=>\n\t\t\t{\n\t\t\t\tlet tmpTemplateValue = pTemplateValue.trim();\n\n\t\t\t\tlet tmpSeparatorIndex = tmpTemplateValue.indexOf('|');\n\n\t\t\t\t// If there is no pipe, the default value will end up being whatever the variable name is.\n\t\t\t\tlet tmpDefaultValue = tmpTemplateValue.substring(tmpSeparatorIndex+1);\n\n\t\t\t\tlet tmpEnvironmentVariableName = (tmpSeparatorIndex > -1) ? tmpTemplateValue.substring(0, tmpSeparatorIndex) : tmpTemplateValue;\n\n\t\t\t\tif (process.env.hasOwnProperty(tmpEnvironmentVariableName))\n\t\t\t\t{\n\t\t\t\t\treturn process.env[tmpEnvironmentVariableName];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\treturn tmpDefaultValue;\n\t\t\t\t}\n\t\t\t});\n    }\n\n    parseSetting(pString)\n    {\n        return this.templateProcessor.parseString(pString);\n    }\n}\n\nmodule.exports = FableSettingsTemplateProcessor;\n}).call(this)}).call(this,require('_process'))\n\n},{\"_process\":34}],25:[function(require,module,exports){\n/**\n* Fable Settings Add-on\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n* @module Fable Settings\n*/\n\nconst libPrecedent = require('precedent');\nconst libFableSettingsTemplateProcessor = require('./Fable-Settings-TemplateProcessor.js');\n\nclass FableSettings\n{\n\tconstructor(pFableSettings)\n\t{\n\t\t// Expose the dependencies for downstream re-use\n\t\tthis.dependencies = (\n\t\t\t{\n\t\t\t\tprecedent: libPrecedent\n\t\t\t});\n\n\t\t// Initialize the settings value template processor\n\t\tthis.settingsTemplateProcessor = new libFableSettingsTemplateProcessor(this.dependencies);\n\n\t\t// set straight away so anything that uses it respects the initial setting\n\t\tthis._configureEnvTemplating(pFableSettings);\n\n\t\tthis.default = this.buildDefaultSettings();\n\n\t\t// Construct a new settings object\n\t\tlet tmpSettings = this.merge(pFableSettings, this.buildDefaultSettings());\n\n\t\t// The base settings object (what they were on initialization, before other actors have altered them)\n\t\tthis.base = JSON.parse(JSON.stringify(tmpSettings));\n\n\t\tif (tmpSettings.DefaultConfigFile)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\t// If there is a DEFAULT configuration file, try to load and merge it.\n\t\t\t\ttmpSettings = this.merge(require(tmpSettings.DefaultConfigFile), tmpSettings);\n\t\t\t}\n\t\t\tcatch (pException)\n\t\t\t{\n\t\t\t\t// Why this?  Often for an app we want settings to work out of the box, but\n\t\t\t\t// would potentially want to have a config file for complex settings.\n\t\t\t\tconsole.log('Fable-Settings Warning: Default configuration file specified but there was a problem loading it.  Falling back to base.');\n\t\t\t\tconsole.log('     Loading Exception: '+pException);\n\t\t\t}\n\t\t}\n\n\t\tif (tmpSettings.ConfigFile)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\t// If there is a configuration file, try to load and merge it.\n\t\t\t\ttmpSettings = this.merge(require(tmpSettings.ConfigFile), tmpSettings);\n\t\t\t}\n\t\t\tcatch (pException)\n\t\t\t{\n\t\t\t\t// Why this?  Often for an app we want settings to work out of the box, but\n\t\t\t\t// would potentially want to have a config file for complex settings.\n\t\t\t\tconsole.log('Fable-Settings Warning: Configuration file specified but there was a problem loading it.  Falling back to base.');\n\t\t\t\tconsole.log('     Loading Exception: '+pException);\n\t\t\t}\n\t\t}\n\n\t\tthis.settings = tmpSettings;\n\t}\n\n\t// Build a default settings object.  Use the JSON jimmy to ensure it is always a new object.\n\tbuildDefaultSettings()\n\t{\n\t\treturn JSON.parse(JSON.stringify(require('./Fable-Settings-Default')));\n\t}\n\n\t// Update the configuration for environment variable templating based on the current settings object\n\t_configureEnvTemplating(pSettings)\n\t{\n\t\t// default environment variable templating to on\n\t\tthis._PerformEnvTemplating = !pSettings || pSettings.NoEnvReplacement !== true;\n\t}\n\n\t// Resolve (recursive) any environment variables found in settings object.\n\t_resolveEnv(pSettings)\n\t{\n\t\tfor (const tmpKey in pSettings)\n\t\t{\n\t\t\tif (typeof(pSettings[tmpKey]) === 'object')\n\t\t\t{\n\t\t\t\tthis._resolveEnv(pSettings[tmpKey]);\n\t\t\t}\n\t\t\telse if (typeof(pSettings[tmpKey]) === 'string')\n\t\t\t{\n\t\t\t\tpSettings[tmpKey] = this.settingsTemplateProcessor.parseSetting(pSettings[tmpKey]);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Check to see if a value is an object (but not an array).\n\t */\n\t_isObject(value)\n\t{\n\t\treturn typeof(value) === 'object' && !Array.isArray(value);\n\t}\n\n\t/**\n\t * Merge two plain objects. Keys that are objects in both will be merged property-wise.\n\t */\n\t_deepMergeObjects(toObject, fromObject)\n\t{\n\t\tif (!fromObject || !this._isObject(fromObject))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tObject.keys(fromObject).forEach((key) =>\n\t\t{\n\t\t\tconst fromValue = fromObject[key];\n\t\t\tif (this._isObject(fromValue))\n\t\t\t{\n\t\t\t\tconst toValue = toObject[key];\n\t\t\t\tif (toValue && this._isObject(toValue))\n\t\t\t\t{\n\t\t\t\t\t// both are objects, so do a recursive merge\n\t\t\t\t\tthis._deepMergeObjects(toValue, fromValue);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttoObject[key] = fromValue;\n\t\t});\n\t\treturn toObject;\n\t}\n\n\t// Merge some new object into the existing settings.\n\tmerge(pSettingsFrom, pSettingsTo)\n\t{\n\t\t// If an invalid settings from object is passed in (e.g. object constructor without passing in anything) this should still work\n\t\tlet tmpSettingsFrom = (typeof(pSettingsFrom) === 'object') ? pSettingsFrom : {};\n\t\t// Default to the settings object if none is passed in for the merge.\n\t\tlet tmpSettingsTo = (typeof(pSettingsTo) === 'object') ? pSettingsTo : this.settings;\n\n\t\t// do not mutate the From object property values\n\t\tlet tmpSettingsFromCopy = JSON.parse(JSON.stringify(tmpSettingsFrom));\n\t\ttmpSettingsTo = this._deepMergeObjects(tmpSettingsTo, tmpSettingsFromCopy);\n\n\t\tif (this._PerformEnvTemplating)\n\t\t{\n\t\t\tthis._resolveEnv(tmpSettingsTo);\n\t\t}\n\t\t// Update env tempating config, since we just updated the config object, and it may have changed\n\t\tthis._configureEnvTemplating(tmpSettingsTo);\n\n\t\treturn tmpSettingsTo;\n\t}\n\n\t// Fill in settings gaps without overwriting settings that are already there\n\tfill(pSettingsFrom)\n\t{\n\t\t// If an invalid settings from object is passed in (e.g. object constructor without passing in anything) this should still work\n\t\tlet tmpSettingsFrom = (typeof(pSettingsFrom) === 'object') ? pSettingsFrom : {};\n\n\t\t// do not mutate the From object property values\n\t\tlet tmpSettingsFromCopy = JSON.parse(JSON.stringify(tmpSettingsFrom));\n\n\t\tthis.settings = this._deepMergeObjects(tmpSettingsFromCopy, this.settings);\n\n\t\treturn this.settings;\n\t}\n};\n\n// This is for backwards compatibility\nfunction autoConstruct(pSettings)\n{\n\treturn new FableSettings(pSettings);\n}\n\nmodule.exports = FableSettings;\nmodule.exports.new = autoConstruct;\nmodule.exports.precedent = libPrecedent;\n},{\"./Fable-Settings-Default\":23,\"./Fable-Settings-TemplateProcessor.js\":24,\"precedent\":31}],26:[function(require,module,exports){\n/**\n* Random Byte Generator - Browser version\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n*/\n\n// Adapted from node-uuid (https://github.com/kelektiv/node-uuid)\n// Unique ID creation requires a high quality random # generator.  In the\n// browser this is a little complicated due to unknown quality of Math.random()\n// and inconsistent support for the `crypto` API.  We do the best we can via\n// feature-detection\nclass RandomBytes\n{\n\tconstructor()\n\t{\n\n\t\t// getRandomValues needs to be invoked in a context where \"this\" is a Crypto\n\t\t// implementation. Also, find the complete implementation of crypto on IE11.\n\t\tthis.getRandomValues = (typeof(crypto) != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto)) ||\n                      \t\t(typeof(msCrypto) != 'undefined' && typeof window.msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto));\n\t}\n\n\t// WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto\n\tgenerateWhatWGBytes()\n\t{\n\t\tlet tmpBuffer = new Uint8Array(16); // eslint-disable-line no-undef\n\n\t\tthis.getRandomValues(tmpBuffer);\n\t\treturn tmpBuffer;\n\t}\n\n\t// Math.random()-based (RNG)\n\tgenerateRandomBytes()\n\t{\n\t\t// If all else fails, use Math.random().  It's fast, but is of unspecified\n\t\t// quality.\n\t\tlet tmpBuffer = new Uint8Array(16); // eslint-disable-line no-undef\n\n\t\tfor (let i = 0, tmpValue; i < 16; i++)\n\t\t{\n\t\t\tif ((i & 0x03) === 0)\n\t\t\t{\n\t\t\t\ttmpValue = Math.random() * 0x100000000;\n\t\t\t}\n\n\t\t\ttmpBuffer[i] = tmpValue >>> ((i & 0x03) << 3) & 0xff;\n\t\t}\n\n\t\treturn tmpBuffer;\n\t}\n\n\tgenerate()\n\t{\n\t\tif (this.getRandomValues)\n\t\t{\n\t\t\treturn this.generateWhatWGBytes();\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn this.generateRandomBytes();\n\t\t}\n\t}\n}\n\nmodule.exports = RandomBytes;\n\n},{}],27:[function(require,module,exports){\n/**\n* Fable UUID Generator\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n* @module Fable UUID\n*/\n\n/**\n* Fable Solution UUID Generation Main Class\n*\n* @class FableUUID\n* @constructor\n*/\n\nvar libRandomByteGenerator = require('./Fable-UUID-Random.js')\n\nclass FableUUID\n{\n\tconstructor(pSettings)\n\t{\n\t\t// Determine if the module is in \"Random UUID Mode\" which means just use the random character function rather than the v4 random UUID spec.\n\t\t// Note this allows UUIDs of various lengths (including very short ones) although guaranteed uniqueness goes downhill fast.\n\t\tthis._UUIDModeRandom = (typeof(pSettings) === 'object') && (pSettings.hasOwnProperty('UUIDModeRandom')) ? (pSettings.UUIDModeRandom == true) : false;\n\t\t// These two properties are only useful if we are in Random mode.  Otherwise it generates a v4 spec\n\t\t// Length for \"Random UUID Mode\" is set -- if not set it to 8\n\t\tthis._UUIDLength = (typeof(pSettings) === 'object') && (pSettings.hasOwnProperty('UUIDLength')) ? (pSettings.UUIDLength + 0) : 8;\n\t\t// Dictionary for \"Random UUID Mode\"\n\t\tthis._UUIDRandomDictionary = (typeof(pSettings) === 'object') && (pSettings.hasOwnProperty('UUIDDictionary')) ? (pSettings.UUIDDictionary + 0) : '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';\n\n\t\tthis.randomByteGenerator = new libRandomByteGenerator();\n\n\t\t// Lookup table for hex codes\n\t\tthis._HexLookup = [];\n\t\tfor (let i = 0; i < 256; ++i)\n\t\t{\n\t\t\tthis._HexLookup[i] = (i + 0x100).toString(16).substr(1);\n\t\t}\n\t}\n\n\t// Adapted from node-uuid (https://github.com/kelektiv/node-uuid)\n\tbytesToUUID(pBuffer)\n\t{\n\t\tlet i = 0;\n\t\t// join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4\n\t\treturn ([\n\t\t\t\t\tthis._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], \n\t\t\t\t\tthis._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], '-',\n\t\t\t\t\tthis._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], '-',\n\t\t\t\t\tthis._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], '-',\n\t\t\t\t\tthis._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], '-',\n\t\t\t\t\tthis._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]]\n\t\t\t\t]).join('');\n\t}\n\n\t// Adapted from node-uuid (https://github.com/kelektiv/node-uuid)\n\tgenerateUUIDv4()\n\t{\n\t\tlet tmpBuffer = new Array(16);\n\t\tvar tmpRandomBytes = this.randomByteGenerator.generate();\n\n\t\t// Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\t\ttmpRandomBytes[6] = (tmpRandomBytes[6] & 0x0f) | 0x40;\n\t\ttmpRandomBytes[8] = (tmpRandomBytes[8] & 0x3f) | 0x80;\n\n\t\treturn this.bytesToUUID(tmpRandomBytes);\n\t}\n\n\t// Simple random UUID generation\n\tgenerateRandom()\n\t{\n\t\tlet tmpUUID = '';\n\n\t\tfor (let i = 0; i < this._UUIDLength; i++)\n\t\t{\n\t\t\ttmpUUID += this._UUIDRandomDictionary.charAt(Math.floor(Math.random() * (this._UUIDRandomDictionary.length-1)));\n\t\t}\n\n\t\treturn tmpUUID;\n\t}\n\n\t// Adapted from node-uuid (https://github.com/kelektiv/node-uuid)\n\tgetUUID()\n\t{\n\t\tif (this._UUIDModeRandom)\n\t\t{\n\t\t\treturn this.generateRandom();\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn this.generateUUIDv4();\n\t\t}\n\t}\n}\n\n// This is for backwards compatibility\nfunction autoConstruct(pSettings)\n{\n\treturn new FableUUID(pSettings);\n}\n\n\nmodule.exports = FableUUID;\nmodule.exports.new = autoConstruct;\n\n},{\"./Fable-UUID-Random.js\":26}],28:[function(require,module,exports){\nclass FableUtility\n{\n\t// Underscore and lodash have a behavior, _.template, which compiles a\n\t// string-based template with code snippets into simple executable pieces,\n\t// with the added twist of returning a precompiled function ready to go.\n\t//\n\t// NOTE: This does not implement underscore escape expressions\n\t// NOTE: This does not implement underscore magic browser variable assignment\n\t//\n\t// This is an implementation of that.\n\t// TODO: Make this use precedent, add configuration, add debugging.\n\tconstructor(pFable, pTemplateText)\n\t{\n\t\tthis.fable = pFable;\n\n\t\t// These are the exact regex's used in lodash/underscore\n\t\t// TODO: Switch this to precedent\n\t\tthis.Matchers = (\n\t\t\t{\n\t\t        Evaluate: /<%([\\s\\S]+?)%>/g,\n\t\t        Interpolate: /<%=([\\s\\S]+?)%>/g,\n\t    \t\tEscaper: /\\\\|'|\\r|\\n|\\t|\\u2028|\\u2029/g,\n\t    \t\tUnescaper: /\\\\(\\\\|'|r|n|t|u2028|u2029)/g,\n\t\t\t\t// This is how underscore does it, so we are keeping it for now.\n\t    \t\tGuaranteedNonMatch: /.^/\n\t\t    });\n\n\t    // This is a helper for the escaper and unescaper functions.\n\t    // Right now we are going to keep what underscore is doing, but, not forever.\n\t    this.templateEscapes = {\n\t        '\\\\': '\\\\',\n\t        \"'\": \"'\",\n\t        'r': '\\r',\n\t        '\\r': 'r',\n\t        'n': '\\n',\n\t        '\\n': 'n',\n\t        't': '\\t',\n\t        '\\t': 't',\n\t        'u2028': '\\u2028',\n\t        '\\u2028': 'u2028',\n\t        'u2029': '\\u2029',\n\t        '\\u2029': 'u2029'\n\t    };\n\n\t    // This is defined as such to underscore that it is a dynamic programming\n\t    // function on this class.\n\t    this.renderFunction = ()=>{return ``};\n\t}\n\n\t// Underscore and lodash have a behavior, _.extend, which merges objects.\n\t// Now that es6 gives us this, use the native thingy.\n\textend(pDestinationObject, ...pSourceObjects)\n\t{\n\t\treturn Object.assign(pDestinationObject, ...pSourceObjects);\n\t}\n\n\trenderTemplate(pData)\n\t{\n\t\treturn this.renderFunction(pData);\n\t}\n\n\ttemplateFunction(pData)\n\t{\n\t\tlet fRenderTemplateBound = this.renderTemplate.bind(this);\n\t\treturn fRenderTemplateBound;\n\t}\n\n\tbuildTemplateFunction(pTemplateText, pData)\n    {\n    \t// For now this is being kept in a weird form ... this is to mimic the old\n    \t// underscore code until this is rewritten using precedent.\n        this.TemplateSource = \"__p+='\" + pTemplateText\n            .replace(this.Matchers.Escaper,\n            \t(pMatch)=>\n\t            {\n\t                return `\\\\${this.templateEscapes[pMatch]}`;\n\t            })\n            .replace(this.Matchers.Interpolate || this.Matchers.GuaranteedNonMatch,\n            \t(pMatch, pCode) =>\n            \t{\n\t                return `'+\\n(${decodeURIComponent(pCode)})+\\n'`;\n\t            })\n\t        .replace(this.Matchers.Evaluate || this.Matchers.GuaranteedNonMatch,\n\t\t\t\t(pMatch, pCode) =>\n            \t{\n\t                return `';\\n${decodeURIComponent(pCode)}\\n;__p+='`;\n\t            }) + `';\\n`;\n\n\n        this.TemplateSource = `with(pTemplateDataObject||{}){\\n${this.TemplateSource}}\\n`;\n        this.TemplateSource = `var __p='';var print=function(){__p+=Array.prototype.join.call(arguments, '')};\\n${this.TemplateSource}return __p;\\n`;\n\n        this.renderFunction = new Function('pTemplateDataObject', this.TemplateSource);\n\n        if (typeof(pData) != 'undefined')\n        {\n            return this.renderFunction(pData);\n        }\n\n        // Provide the compiled function source as a convenience for build time\n        // precompilation.\n        this.TemplateSourceCompiled = 'function(obj){\\n' + this.TemplateSource + '}';\n\n        return this.templateFunction();\n\t}\n}\n\nmodule.exports = FableUtility;\n},{}],29:[function(require,module,exports){\nconst libFableUtilityTemplate = require('./Fable-Utility-Template.js');\nconst libAsyncWaterfall = require('async/waterfall');\nconst libAsyncEachLimit = require('async/eachLimit');\n\nclass FableUtility\n{\n\tconstructor(pFable)\n\t{\n\t\tthis.fable = pFable;\n\n\t\t// These two functions are used extensively throughout\n\t\tthis.waterfall = libAsyncWaterfall;\n\t\tthis.eachLimit = libAsyncEachLimit;\n\t}\n\n\t// Underscore and lodash have a behavior, _.extend, which merges objects.\n\t// Now that es6 gives us this, use the native thingy.\n\textend(pDestinationObject, ...pSourceObjects)\n\t{\n\t\treturn Object.assign(pDestinationObject, ...pSourceObjects);\n\t}\n\n\t// Underscore and lodash have a behavior, _.template, which compiles a\n\t// string-based template with code snippets into simple executable pieces,\n\t// with the added twist of returning a precompiled function ready to go.\n\ttemplate(pTemplateText, pData)\n\t{\n\t\tlet tmpTemplate = new libFableUtilityTemplate(this.fable, pTemplateText);\n\n\t\treturn tmpTemplate.buildTemplateFunction(pTemplateText, pData);\n\t}\n\n\t// This is a safe, modern version of chunk from underscore\n\t// Algorithm pulled from a mix of these two polyfills:\n\t// https://github.com/you-dont-need/You-Dont-Need-Lodash-Underscore#_chunk\n\t// https://youmightnotneed.com/lodash\n\t// This implementation was most tolerant in browsers.  Uglify can fix the rest.\n\tchunk (pInput, pChunkSize, pChunkCache)\n\t{\n\t\tlet tmpInputArray = [...pInput];\n\t\t// Note lodash defaults to 1, underscore defaults to 0\n\t\tlet tmpChunkSize = (typeof(pChunkSize) == 'number') ? pChunkSize : 0;\n\t\tlet tmpChunkCache = (typeof(pChunkCache) != 'undefined') ? pChunkCache : [];\n\n\t\tif (tmpChunkSize <= 0)\n\t\t{\n\t\t\treturn tmpChunkCache;\n\t\t}\n\n\t\twhile (tmpInputArray.length)\n\t\t{\n\t\t\ttmpChunkCache.push(tmpInputArray.splice(0, tmpChunkSize));\n\t\t}\n\n\t\treturn tmpChunkCache;\n\t}\n}\n\nmodule.exports = FableUtility;\n},{\"./Fable-Utility-Template.js\":28,\"async/eachLimit\":2,\"async/waterfall\":16}],30:[function(require,module,exports){\n/**\n* Fable Application Services Support Library\n* @license MIT\n* @author <steven@velozo.com>\n*/\nconst libFableSettings = require('fable-settings');\nconst libFableUUID = require('fable-uuid');\nconst libFableLog = require('fable-log');\n\nconst libFableUtility = require('./Fable-Utility.js')\n\nclass Fable\n{\n\tconstructor(pSettings)\n\t{\n\t\tlet tmpSettings = new libFableSettings(pSettings);\n\n\t\tthis.settingsManager = tmpSettings;\n\n\t\t// Instantiate the UUID generator\n\t\tthis.libUUID = new libFableUUID(this.settingsManager.settings);\n\n\t\tthis.log = new libFableLog(this.settingsManager.settings);\n\t\tthis.log.initialize();\n\n\t\tthis.Utility = new libFableUtility(this);\n\n\t\t// Built-in dependencies ... more can be added here.\n\t\tthis.Dependencies = (\n\t\t\t{\n\t\t\t\tprecedent: libFableSettings.precedent\n\t\t\t});\n\t}\n\n\tget settings()\n\t{\n\t\treturn this.settingsManager.settings;\n\t}\n\n\tget fable()\n\t{\n\t\treturn this;\n\t}\n\n\tgetUUID()\n\t{\n\t\treturn this.libUUID.getUUID();\n\t}\n}\n\n// This is for backwards compatibility\nfunction autoConstruct(pSettings)\n{\n\treturn new Fable(pSettings);\n}\n\nmodule.exports = Fable;\nmodule.exports.new = autoConstruct;\n\nmodule.exports.LogProviderBase = libFableLog.LogProviderBase;\n\nmodule.exports.precedent = libFableSettings.precedent;\n},{\"./Fable-Utility.js\":29,\"fable-log\":22,\"fable-settings\":25,\"fable-uuid\":27}],31:[function(require,module,exports){\n/**\n* Precedent Meta-Templating\n*\n* @license     MIT\n*\n* @author      Steven Velozo <steven@velozo.com>\n*\n* @description Process text streams, parsing out meta-template expressions.\n*/\nvar libWordTree = require(`./WordTree.js`);\nvar libStringParser = require(`./StringParser.js`);\n\nclass Precedent\n{\n\t/**\n\t * Precedent Constructor\n\t */\n\tconstructor()\n\t{\n\t\tthis.WordTree = new libWordTree();\n\t\t\n\t\tthis.StringParser = new libStringParser();\n\n\t\tthis.ParseTree = this.WordTree.ParseTree;\n\t}\n\t\n\t/**\n\t * Add a Pattern to the Parse Tree\n\t * @method addPattern\n\t * @param {Object} pTree - A node on the parse tree to push the characters into\n\t * @param {string} pPattern - The string to add to the tree\n\t * @param {number} pIndex - callback function\n\t * @return {bool} True if adding the pattern was successful\n\t */\n\taddPattern(pPatternStart, pPatternEnd, pParser)\n\t{\n\t\treturn this.WordTree.addPattern(pPatternStart, pPatternEnd, pParser);\n\t}\n\t\n\t/**\n\t * Parse a string with the existing parse tree\n\t * @method parseString\n\t * @param {string} pString - The string to parse\n\t * @return {string} The result from the parser\n\t */\n\tparseString(pString)\n\t{\n\t\treturn this.StringParser.parseString(pString, this.ParseTree);\n\t}\n}\n\nmodule.exports = Precedent;\n\n},{\"./StringParser.js\":32,\"./WordTree.js\":33}],32:[function(require,module,exports){\n/**\n* String Parser\n*\n* @license     MIT\n*\n* @author      Steven Velozo <steven@velozo.com>\n*\n* @description Parse a string, properly processing each matched token in the word tree.\n*/\n\nclass StringParser\n{\n\t/**\n\t * StringParser Constructor\n\t */\n\tconstructor()\n\t{\n\t}\n\t\n\t/**\n\t * Create a fresh parsing state object to work with.\n\t * @method newParserState\n\t * @param {Object} pParseTree - A node on the parse tree to begin parsing from (usually root)\n\t * @return {Object} A new parser state object for running a character parser on\n\t * @private\n\t */\n\tnewParserState (pParseTree)\n\t{\n\t\treturn (\n\t\t{\n\t\t\tParseTree: pParseTree,\n\n\t\t\tOutput: '',\n\t\t\tOutputBuffer: '',\n\n\t\t\tPattern: false,\n\n\t\t\tPatternMatch: false,\n\t\t\tPatternMatchOutputBuffer: ''\n\t\t});\n\t}\n\t\t\n\t/**\n\t * Assign a node of the parser tree to be the next potential match.\n\t * If the node has a PatternEnd property, it is a valid match and supercedes the last valid match (or becomes the initial match).\n\t * @method assignNode\n\t * @param {Object} pNode - A node on the parse tree to assign\n\t * @param {Object} pParserState - The state object for the current parsing task\n\t * @private\n\t */\n\tassignNode (pNode, pParserState)\n\t{\n\t\tpParserState.PatternMatch = pNode;\n\n\t\t// If the pattern has a END we can assume it has a parse function...\n\t\tif (pParserState.PatternMatch.hasOwnProperty('PatternEnd'))\n\t\t{\n\t\t\t// ... this is the legitimate start of a pattern.\n\t\t\tpParserState.Pattern = pParserState.PatternMatch;\n\t\t}\n\t}\n\t\n\t/**\n\t * Append a character to the output buffer in the parser state.\n\t * This output buffer is used when a potential match is being explored, or a match is being explored.\n\t * @method appendOutputBuffer\n\t * @param {string} pCharacter - The character to append\n\t * @param {Object} pParserState - The state object for the current parsing task\n\t * @private\n\t */\n\tappendOutputBuffer (pCharacter, pParserState)\n\t{\n\t\tpParserState.OutputBuffer += pCharacter;\n\t}\n\t\n\t/**\n\t * Flush the output buffer to the output and clear it.\n\t * @method flushOutputBuffer\n\t * @param {Object} pParserState - The state object for the current parsing task\n\t * @private\n\t */\n\tflushOutputBuffer (pParserState)\n\t{\n\t\tpParserState.Output += pParserState.OutputBuffer;\n\t\tpParserState.OutputBuffer = '';\n\t}\n\n\t\n\t/**\n\t * Check if the pattern has ended.  If it has, properly flush the buffer and start looking for new patterns.\n\t * @method checkPatternEnd\n\t * @param {Object} pParserState - The state object for the current parsing task\n\t * @private\n\t */\n\tcheckPatternEnd (pParserState)\n\t{\n\t\tif ((pParserState.OutputBuffer.length >= pParserState.Pattern.PatternEnd.length+pParserState.Pattern.PatternStart.length) && \n\t\t\t(pParserState.OutputBuffer.substr(-pParserState.Pattern.PatternEnd.length) === pParserState.Pattern.PatternEnd))\n\t\t{\n\t\t\t// ... this is the end of a pattern, cut off the end tag and parse it.\n\t\t\t// Trim the start and end tags off the output buffer now\n\t\t\tpParserState.OutputBuffer = pParserState.Pattern.Parse(pParserState.OutputBuffer.substr(pParserState.Pattern.PatternStart.length, pParserState.OutputBuffer.length - (pParserState.Pattern.PatternStart.length+pParserState.Pattern.PatternEnd.length)));\n\t\t\t// Flush the output buffer.\n\t\t\tthis.flushOutputBuffer(pParserState);\n\t\t\t// End pattern mode\n\t\t\tpParserState.Pattern = false;\n\t\t\tpParserState.PatternMatch = false;\n\t\t}\n\t}\n\t\n\t/**\n\t * Parse a character in the buffer.\n\t * @method parseCharacter\n\t * @param {string} pCharacter - The character to append\n\t * @param {Object} pParserState - The state object for the current parsing task\n\t * @private\n\t */\n\tparseCharacter (pCharacter, pParserState)\n\t{\n\t\t// (1) If we aren't in a pattern match, and we aren't potentially matching, and this may be the start of a new pattern....\n\t\tif (!pParserState.PatternMatch && pParserState.ParseTree.hasOwnProperty(pCharacter))\n\t\t{\n\t\t\t// ... assign the node as the matched node.\n\t\t\tthis.assignNode(pParserState.ParseTree[pCharacter], pParserState);\n\t\t\tthis.appendOutputBuffer(pCharacter, pParserState);\n\t\t}\n\t\t// (2) If we are in a pattern match (actively seeing if this is part of a new pattern token)\n\t\telse if (pParserState.PatternMatch)\n\t\t{\n\t\t\t// If the pattern has a subpattern with this key\n\t\t\tif (pParserState.PatternMatch.hasOwnProperty(pCharacter))\n\t\t\t{\n\t\t\t\t// Continue matching patterns.\n\t\t\t\tthis.assignNode(pParserState.PatternMatch[pCharacter], pParserState);\n\t\t\t}\n\t\t\tthis.appendOutputBuffer(pCharacter, pParserState);\n\t\t\tif (pParserState.Pattern)\n\t\t\t{\n\t\t\t\t// ... Check if this is the end of the pattern (if we are matching a valid pattern)...\n\t\t\t\tthis.checkPatternEnd(pParserState);\n\t\t\t}\n\t\t}\n\t\t// (3) If we aren't in a pattern match or pattern, and this isn't the start of a new pattern (RAW mode)....\n\t\telse\n\t\t{\n\t\t\tpParserState.Output += pCharacter;\n\t\t}\n\t}\n\t\n\t/**\n\t * Parse a string for matches, and process any template segments that occur.\n\t * @method parseString\n\t * @param {string} pString - The string to parse.\n\t * @param {Object} pParseTree - The parse tree to begin parsing from (usually root)\n\t */\n\tparseString (pString, pParseTree)\n\t{\n\t\tlet tmpParserState = this.newParserState(pParseTree);\n\n\t\tfor (var i = 0; i < pString.length; i++)\n\t\t{\n\t\t\t// TODO: This is not fast.\n\t\t\tthis.parseCharacter(pString[i], tmpParserState);\n\t\t}\n\t\t\n\t\tthis.flushOutputBuffer(tmpParserState);\n\t\t\n\t\treturn tmpParserState.Output;\n\t}\n}\n\nmodule.exports = StringParser;\n\n},{}],33:[function(require,module,exports){\n/**\n* Word Tree\n*\n* @license     MIT\n*\n* @author      Steven Velozo <steven@velozo.com>\n*\n* @description Create a tree (directed graph) of Javascript objects, one character per object.\n*/\n\nclass WordTree\n{\n\t/**\n\t * WordTree Constructor\n\t */\n\tconstructor()\n\t{\n\t\tthis.ParseTree = {};\n\t}\n\t\n\t/** \n\t * Add a child character to a Parse Tree node\n\t * @method addChild\n\t * @param {Object} pTree - A parse tree to push the characters into\n\t * @param {string} pPattern - The string to add to the tree\n\t * @param {number} pIndex - The index of the character in the pattern\n\t * @returns {Object} The resulting leaf node that was added (or found)\n\t * @private\n\t */\n\taddChild (pTree, pPattern, pIndex)\n\t{\n\t\tif (!pTree.hasOwnProperty(pPattern[pIndex]))\n\t\t\tpTree[pPattern[pIndex]] = {};\n\t\t\n\t\treturn pTree[pPattern[pIndex]];\n\t}\n\t\n\t/** Add a Pattern to the Parse Tree\n\t * @method addPattern\n\t * @param {Object} pPatternStart - The starting string for the pattern (e.g. \"${\")\n\t * @param {string} pPatternEnd - The ending string for the pattern (e.g. \"}\")\n\t * @param {number} pParser - The function to parse if this is the matched pattern, once the Pattern End is met.  If this is a string, a simple replacement occurs.\n\t * @return {bool} True if adding the pattern was successful\n\t */\n\taddPattern (pPatternStart, pPatternEnd, pParser)\n\t{\n\t\tif (pPatternStart.length < 1)\n\t\t\treturn false;\n\n\t\tif ((typeof(pPatternEnd) === 'string') && (pPatternEnd.length < 1))\n\t\t\treturn false;\n\n\t\tlet tmpLeaf = this.ParseTree;\n\n\t\t// Add the tree of leaves iteratively\n\t\tfor (var i = 0; i < pPatternStart.length; i++)\n\t\t\ttmpLeaf = this.addChild(tmpLeaf, pPatternStart, i);\n\n\t\ttmpLeaf.PatternStart = pPatternStart;\n\t\ttmpLeaf.PatternEnd = ((typeof(pPatternEnd) === 'string') && (pPatternEnd.length > 0)) ? pPatternEnd : pPatternStart;\n\t\ttmpLeaf.Parse = (typeof(pParser) === 'function') ? pParser : \n\t\t\t\t\t\t(typeof(pParser) === 'string') ? () => { return pParser; } :\n\t\t\t\t\t\t(pData) => { return pData; };\n\n\t\treturn true;\n\t}\n}\n\nmodule.exports = WordTree;\n\n},{}],34:[function(require,module,exports){\n// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n},{}],35:[function(require,module,exports){\n(function (setImmediate,clearImmediate){(function (){\nvar nextTick = require('process/browser.js').nextTick;\nvar apply = Function.prototype.apply;\nvar slice = Array.prototype.slice;\nvar immediateIds = {};\nvar nextImmediateId = 0;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) { timeout.close(); };\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(window, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// That's not how node.js implements it but the exposed api is the same.\nexports.setImmediate = typeof setImmediate === \"function\" ? setImmediate : function(fn) {\n  var id = nextImmediateId++;\n  var args = arguments.length < 2 ? false : slice.call(arguments, 1);\n\n  immediateIds[id] = true;\n\n  nextTick(function onNextTick() {\n    if (immediateIds[id]) {\n      // fn.call() is faster so we optimize for the common use-case\n      // @see http://jsperf.com/call-apply-segu\n      if (args) {\n        fn.apply(null, args);\n      } else {\n        fn.call(null);\n      }\n      // Prevent ids from leaking\n      exports.clearImmediate(id);\n    }\n  });\n\n  return id;\n};\n\nexports.clearImmediate = typeof clearImmediate === \"function\" ? clearImmediate : function(id) {\n  delete immediateIds[id];\n};\n}).call(this)}).call(this,require(\"timers\").setImmediate,require(\"timers\").clearImmediate)\n\n},{\"process/browser.js\":34,\"timers\":35}],36:[function(require,module,exports){\n/**\n* @license MIT\n* @author <steven@velozo.com>\n*/\n\n/**\n* Choreographic browser shim loader\n*/\n\n// Load the informary module into the browser global automatically.\nvar libChoreographic = require('./Choreographic.js');\n\nif (typeof(window) === 'object')\n    window.Choreographic = libChoreographic;\n\nmodule.exports = libChoreographic;\n},{\"./Choreographic.js\":37}],37:[function(require,module,exports){\n(function (process){(function (){\n// A simple host for managing scripts with isolated data outputs each run automatically\n// both on the development box as well as in production if necessary.\n\n// If we want to load a configuration file, just set this property in pConfiguration:\n// ConfigFile:`${__dirname}/Extra-Configuration.json`,\n\n/*\n * This will have some run-specific data in settings:\n *\n * (DataFolder is where the data goes)\n\n {\n\t\"App\":\n\t{\n\t\t\"Hash\": \"Script\",\n\t\t\"RunID\": \"Script-Run-2022-08-12-15-35-01-21-859\",\n\t\t\"DataRoot\": \"/some/folderlike/container/for/rundata/\",\n\t\t\"DataFolder\": \"/some/folderlike/container/for/rundata/Script-Run-2022-08-12-15-35-01-21-859/\"\n\t}\n }\n\n */\n\nconst libFS = require('fs');\n\n// This expects either a config object or a string that points to a file.\nclass Choreographic\n{\n\tconstructor(pConfiguration)\n\t{\n\t\tthis._InitialConfiguration = (typeof(pConfiguration) == 'object') ? pConfiguration : {};\n\t\tthis._InitialConfigurationFile = {};\n\n\t\tthis._Dependencies = (\n\t\t\t{\n\t\t\t\tfs: libFS\n\t\t\t});\n\n\t\tif (typeof(pConfiguration) == 'string')\n\t\t{\n\t\t\tthis.loadInitialConfigurationFile(pConfiguration);\n\t\t}\n\t\telse if ((this._InitialConfiguration.hasOwnProperty('ConfigFile')))\n\t\t{\n\t\t\t// We are going to manually override the Fable auto-config loading\n\t\t\t// So we can generate extra elements regarding the run-specific folders\n\t\t\tthis.loadInitialConfigurationFile(this._InitialConfiguration.ConfigFile);\n\t\t}\n\n\t\tthis.settings = null;\n\n\t\t// Timestamps will just be the long ints\n\t\tthis.timeStamps = {};\n\t\t// ProgressTrackers have an object format of: {Hash:'SomeHash',EndTime:UINT,CurrentTime:UINT,TotalCount:INT,CurrentCount:INT}\n\t\tthis.progressTrackers = {};\n\n\t\tthis.initializeSettingsObject();\n\n\t\tthis.initializeRunSpecificData();\n\t}\n\n\t/************************************************************************\n\t * BEGINNING OF -->  Script Initialization Functions\n\t */\n\tloadInitialConfigurationFile(pConfigurationFile)\n\t{\n\t\tif (typeof(pConfigurationFile) == 'string')\n\t\t{\n\t\t\t// Try to load the config file.\n\t\t\ttry\n\t\t\t{\n\t\t\t\tthis._InitialConfigurationFile = require(pConfigurationFile);\n\t\t\t\tconsole.log(`Loaded configuration file [${pConfigurationFile}].`)\n\t\t\t}\n\t\t\tcatch (pConfigFileLoadException)\n\t\t\t{\n\t\t\t\tthis._InitialConfigurationFile = {};\n\t\t\t\tconsole.log(`Error attempting to load configuration file [${pConfigurationFile}]: ${pConfigFileLoadException}`);\n\t\t\t}\n\t\t}\n\t}\n\n\tinitializeSettingsObject()\n\t{\n\t\t// Merge the file and the passed-in config.\n\t\t// The passed-in config takes precedence in this spread merge operation.\n\t\tthis.settings = { ...this._InitialConfigurationFile, ...this._InitialConfiguration};\n\t}\n\n\tinitializeRunSpecificData()\n\t{\n\t\t// Make sure the app-specific and run-specific object is available.\n\t\tif (!this.settings.hasOwnProperty('App'))\n\t\t{\n\t\t\tthis.settings.App = {};\n\t\t}\n\t\telse if (typeof(this.settings.App) != 'object')\n\t\t{\n\t\t\t// If the App settings thing isn't an object, this is all going to be really challenging.\n\t\t\tconsole.log(`Settings object has an \"App\" property but it is not an object, it is of type ${typeof(this.settings.App)} with a value of [${this.settings.App}].  Moving this property to the \"__ERROR_App\" property.`);\n\t\t\tthis.settings._ERROR_App = this.settings.App;\n\t\t\tthis.settings.App = {};\n\t\t}\n\n\t\tif (!this.settings.App.hasOwnProperty('Hash'))\n\t\t{\n\t\t\t// TODO: Potentially pull the App Name from the config.\n\t\t\tthis.settings.App.Hash = 'ScriptHost';\n\t\t}\n\t\tif (!this.settings.hasOwnProperty('Product'))\n\t\t{\n\t\t\tthis.settings.Product = this.settings.App.Hash;\n\t\t}\n\t\tif (!this.settings.hasOwnProperty('ProductVersion'))\n\t\t{\n\t\t\tthis.settings.ProductVersion = '0.0.0';\n\t\t}\n\n\t\t// Check to see if a folder in the settings for the unique per-run folders.\n\t\t// Note this is the \"data root\" folder, meaning each time you run the script\n\t\t//     a folder will be created in here with a timestamp with logs and data\n\t\t//     from the run.\n\t\t// By default create a \"rundata\" folder in the same place as the code file.\n\t\tif (!this.settings.App.hasOwnProperty('DataRoot'))\n\t\t{\n\t\t\tthis.settings.App.DataRoot = `${process.cwd()}/rundata/`;\n\t\t}\n\n\t\t// Now create the root folder for the rundata.\n\t\t// TODO: Change this to recursive dropbag folder create functions\n\t\tif (!libFS.existsSync(this.settings.App.DataRoot))\n\t\t{\n\t\t\tlibFS.mkdirSync(this.settings.App.DataRoot);\n\t\t}\n\n\t\t// Create a specific run folder (for caching files, output and a log) based on time\n\t\tthis.settings.App.RunTimeStart = new Date();\n\t\t// Small macro to return a 2 digit number that is zero filled on the left\n\t\t// TODO: Tested simple library for data processing as such\n\t\tlet formatDateString = (pDateValue) => { return (`00${pDateValue}`).slice(-2); };\n\n\t\t// Create a unique run hash for this specific run\n\t\tthis.settings.App.RunID = `${this.settings.App.Hash}-Run-${this.settings.App.RunTimeStart.getFullYear()}-${formatDateString(this.settings.App.RunTimeStart.getMonth()+1)}-${formatDateString(this.settings.App.RunTimeStart.getDate())}-${formatDateString(this.settings.App.RunTimeStart.getHours())}-${formatDateString(this.settings.App.RunTimeStart.getMinutes())}-${formatDateString(this.settings.App.RunTimeStart.getSeconds())}-${this.settings.App.RunTimeStart.getMilliseconds()}`;\n\t\tthis.settings.App.DataFolder = `${this.settings.App.DataRoot}${this.settings.App.RunID}`;\n\n\t\t// Now create the run specific data folder\n\t\tlibFS.mkdirSync(this.settings.App.DataFolder);\n\n\t\t// Check to see if there is a log streams object, or create one if there isn't.\n\t\tif (!this.settings.hasOwnProperty('LogStreams'))\n\t\t{\n\t\t\tthis.settings.LogStreams = [];\n\t\t}\n\t\t// Add a log file for this run, in the run specific data folder.\n\t\tthis.settings.LogStreams.push(\n\t\t\t// Because the simpleflatfile log stream writes to console and file, we are good!\n\t\t\t{\n\t\t\t\t\"level\": \"trace\",\n\t\t\t\t\"streamtype\": \"simpleflatfile\",\n\t\t\t\t\"path\": `${this.settings.App.DataFolder}/${this.settings.App.RunID}.log`\n\t\t\t});\n\n\t\tthis.fable = require('fable').new(this.settings);\n\n\t\tthis.log = this.fable.log;\n\n\t\tthis.log.info(`Starting up script host [${this.settings.App.DataFolder}/${this.settings.App.RunID}.log] for ${this.settings.App.Hash}...`);\n\t}\n\t/*\n\t * END OF       -->  Script Initialization Functions\n\t ************************************************************************/\n\n\n\n\t/************************************************************************\n\t * BEGINNING OF -->  Logging and Telemetry Helpers\n\t */\n\tcreateTimeStamp(pTimeStampHash)\n\t{\n\t\tlet tmpTimeStampHash = (typeof(pTimeStampHash) == 'string') ? pTimeStampHash : 'Default';\n\t\tthis.timeStamps[tmpTimeStampHash] = +new Date();\n\t\treturn this.timeStamps[tmpTimeStampHash];\n\t}\n\n\tgetTimeDelta(pTimeStampHash)\n\t{\n\t\tlet tmpTimeStampHash = (typeof(pTimeStampHash) == 'string') ? pTimeStampHash : 'Default';\n\t\tif (this.timeStamps.hasOwnProperty(tmpTimeStampHash))\n\t\t{\n\t\t\tlet tmpEndTime = +new Date();\n\t\t\treturn tmpEndTime-this.timeStamps[tmpTimeStampHash];\t\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tlogTimeDelta(pTimeStampHash, pMessage)\n\t{\n\t\tlet tmpTimeStampHash = (typeof(pTimeStampHash) == 'string') ? pTimeStampHash : 'Default';\n\t\tlet tmpMessage = (typeof(pMessage) !== 'undefined') ? pMessage : `Elapsed for ${tmpTimeStampHash}: `;\n\t\tlet tmpOperationTime = this.getTimeDelta(pTimeStampHash);\n\t\tthis.info(tmpMessage +' ('+tmpOperationTime+'ms)');\n\t\treturn tmpOperationTime;\n\t}\n\n\tcreateProgressTracker(pTotalOperations, pProgressTrackerHash)\n\t{\n\t\tlet tmpProgressTrackerHash = (typeof(pProgressTrackerHash) == 'string') ? pProgressTrackerHash : 'DefaultProgressTracker';\n\t\tlet tmpTotalOperations = (typeof(pTotalOperations) == 'number') ? pTotalOperations : 100;\n\n\t\tlet tmpProgressTracker = (\n\t\t\t{\n\t\t\t\tHash: tmpProgressTrackerHash,\n\t\t\t\tStartTime: this.createTimeStamp(tmpProgressTrackerHash),\n\t\t\t\tEndTime: 0,\n\t\t\t\tCurrentTime: 0,\n\t\t\t\tPercentComplete: -1,\n\t\t\t\tAverageOperationTime: -1,\n\t\t\t\tEstimatedCompletionTime: -1,\n\t\t\t\tTotalCount: tmpTotalOperations,\n\t\t\t\tCurrentCount:-1\n\t\t\t});\n\n\t\tthis.progressTrackers[tmpProgressTrackerHash] = tmpProgressTracker;\n\n\t\treturn tmpProgressTracker;\n\t}\n\n\tsolveProgressTrackerStatus(pProgressTrackerHash)\n\t{\n\t\tlet tmpProgressTrackerHash = (typeof(pProgressTrackerHash) == 'string') ? pProgressTrackerHash : 'DefaultProgressTracker';\n\n\t\tif (!this.progressTrackers.hasOwnProperty(tmpProgressTrackerHash))\n\t\t{\n\t\t\tthis.createProgressTracker(100, tmpProgressTrackerHash);\n\t\t}\n\n\t\tlet tmpProgressTracker = this.progressTrackers[tmpProgressTrackerHash];\n\n\t\ttmpProgressTracker.CurrentTime = this.getTimeDelta(tmpProgressTracker.Hash);\n\n\t\tif ((tmpProgressTracker.CurrentCount > 0) && (tmpProgressTracker.TotalCount > 0))\n\t\t{\n\t\t\ttmpProgressTracker.PercentComplete = (tmpProgressTracker.CurrentCount / tmpProgressTracker.TotalCount) * 100.0;\n\t\t}\n\n\t\tif ((tmpProgressTracker.CurrentCount > 0) && (tmpProgressTracker.CurrentTime > 0))\n\t\t{\n\t\t\ttmpProgressTracker.AverageOperationTime = tmpProgressTracker.CurrentTime / tmpProgressTracker.CurrentCount;\n\t\t}\n\n\t\tif ((tmpProgressTracker.CurrentCount < tmpProgressTracker.TotalCount) && (tmpProgressTracker.AverageOperationTime > 0))\n\t\t{\n\t\t\ttmpProgressTracker.EstimatedCompletionTime = (tmpProgressTracker.TotalCount - tmpProgressTracker.CurrentCount) * tmpProgressTracker.AverageOperationTime;\n\t\t}\n\t}\n\n\tupdateProgressTrackerStatus(pProgressTrackerHash, pCurrentOperations)\n\t{\n\t\tlet tmpProgressTrackerHash = (typeof(pProgressTrackerHash) == 'string') ? pProgressTrackerHash : 'DefaultProgressTracker';\n\t\tlet tmpCurrentOperations = parseInt(pCurrentOperations);\n\n\t\tif (isNaN(tmpCurrentOperations))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!this.progressTrackers.hasOwnProperty(tmpProgressTrackerHash))\n\t\t{\n\t\t\tthis.createProgressTracker(100, tmpProgressTrackerHash);\n\t\t}\n\n\t\tthis.progressTrackers[tmpProgressTrackerHash].CurrentCount = tmpCurrentOperations;\n\t\tthis.progressTrackers[tmpProgressTrackerHash].CurrentTime = this.getTimeDelta(tmpProgressTrackerHash);\n\n\t\tthis.solveProgressTrackerStatus(tmpProgressTrackerHash);\n\n\t\treturn this.progressTrackers[tmpProgressTrackerHash];\n\t}\n\n\tincrementProgressTrackerStatus(pProgressTrackerHash, pIncrementSize)\n\t{\n\t\tlet tmpProgressTrackerHash = (typeof(pProgressTrackerHash) == 'string') ? pProgressTrackerHash : 'DefaultProgressTracker';\n\t\tlet tmpIncrementSize = parseInt(pIncrementSize);\n\n\t\tif (isNaN(tmpIncrementSize))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!this.progressTrackers.hasOwnProperty(tmpProgressTrackerHash))\n\t\t{\n\t\t\tthis.createProgressTracker(100, tmpProgressTrackerHash);\n\t\t}\n\n\t\tthis.progressTrackers[tmpProgressTrackerHash].CurrentCount = this.progressTrackers[tmpProgressTrackerHash].CurrentCount + tmpIncrementSize;\n\t\tthis.progressTrackers[tmpProgressTrackerHash].CurrentTime = this.getTimeDelta(tmpProgressTrackerHash);\n\n\t\tthis.solveProgressTrackerStatus(tmpProgressTrackerHash);\n\n\t\treturn this.progressTrackers[tmpProgressTrackerHash];\n\t}\n\n\tsetProgressTrackerEndTime(pProgressTrackerHash, pCurrentOperations)\n\t{\n\t\tlet tmpProgressTrackerHash = (typeof(pProgressTrackerHash) == 'string') ? pProgressTrackerHash : 'DefaultProgressTracker';\n\t\tlet tmpCurrentOperations = parseInt(pCurrentOperations);\n\n\t\tif (!this.progressTrackers.hasOwnProperty(tmpProgressTrackerHash))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (!isNaN(tmpCurrentOperations))\n\t\t{\n\t\t\tthis.updateProgressTrackerStatus(tmpProgressTrackerHash, tmpCurrentOperations);\n\t\t}\n\n\t\tthis.progressTrackers[tmpProgressTrackerHash].EndTime = this.getTimeDelta(tmpProgressTrackerHash);\n\t\t\n\t\tthis.solveProgressTrackerStatus(tmpProgressTrackerHash);\n\n\t\treturn this.progressTrackers[tmpProgressTrackerHash];\n\t}\n\n\tprintProgressTrackerStatus(pProgressTrackerHash)\n\t{\n\t\tlet tmpProgressTrackerHash = (typeof(pProgressTrackerHash) == 'string') ? pProgressTrackerHash : 'DefaultProgressTracker';\n\t\t\n\t\tif (!this.progressTrackers.hasOwnProperty(tmpProgressTrackerHash))\n\t\t{\n\t\t\tthis.log.info(`>> Progress Tracker ${tmpProgressTrackerHash} does not exist!  No stats to display.`);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tconst tmpProgressTracker = this.progressTrackers[tmpProgressTrackerHash];\n\n\t\t\tif (tmpProgressTracker.CurrentCount < 1)\n\t\t\t{\n\t\t\t\tthis.log.info(`>> Progress Tracker ${tmpProgressTracker.Hash} has no completed operations.  ${tmpProgressTracker.CurrentTime}ms have elapsed since it was started.`);\n\t\t\t}\n\t\t\telse if (tmpProgressTracker.EndTime < 1)\n\t\t\t{\n\t\t\t\tthis.log.info(`>> Progress Tracker ${tmpProgressTracker.Hash} is ${tmpProgressTracker.PercentComplete.toFixed(3)}% completed - ${tmpProgressTracker.CurrentCount} / ${tmpProgressTracker.TotalCount} operations over ${tmpProgressTracker.CurrentTime}ms (median ${tmpProgressTracker.AverageOperationTime.toFixed(3)} per).  Estimated completion in ${tmpProgressTracker.EstimatedCompletionTime.toFixed(0)}ms or ${(tmpProgressTracker.EstimatedCompletionTime / 1000 / 60).toFixed(2)}minutes`)\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.log.info(`>> Progress Tracker ${tmpProgressTracker.Hash} is done and completed ${tmpProgressTracker.CurrentCount} / ${tmpProgressTracker.TotalCount} operations in ${tmpProgressTracker.EndTime}ms.`)\n\t\t\t}\n\t\t}\n\t}\n\n\tlogMemoryResourcesUsed()\n\t{\n\n\t\tconst tmpResourcesUsed = process.memoryUsage().heapUsed / 1024 / 1024;\n\t\tthis.log.info(`Memory usage at ${Math.round(tmpResourcesUsed * 100) / 100} MB`);\t\t\n\t}\n\t/*\n\t * END OF       -->  Logging and Telemetry Helpers\n\t ************************************************************************/\n\n\n\n\t/************************************************************************\n\t * BEGINNING OF -->  Script File Persistence Helpers\n\t */\n\twriteFileToRunDataFolderFromObjectSync(pFileName, pObject)\n\t{\n\t\tlibFS.writeFileSync(`${this.settings.App.DataFolder}/${pFileName}`, JSON.stringify(pObject, null, 4), 'utf8');\n\t}\n\n\twriteFileToRunDataFolderSync(pFileName, pFileContent)\n\t{\n\t\tlibFS.writeFileSync(`${this.settings.App.DataFolder}/${pFileName}`,pFileContent,'utf8');\t\t\n\t}\n\n\twriteTextFileFromArray(pFileName, pFileArray)\n\t{\n\t\tif (!Array.isArray(pFileArray))\n\t\t{\n\t\t\tthis.log.error(`Attempted to write ${pFileName} but the expected array was not an array.`);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlet tmpOutCSVFile = `${this.settings.App.DataFolder}/${pFileName}`;\n\t\t\tfor (let i = 0; i < pFileArray.length; i++)\n\t\t\t{\n\t\t\t\tlibFS.appendFileSync(tmpOutCSVFile, pFileArray[i]+\"\\n\", 'utf8');\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\t * END OF       -->  Script File Persistence Helpers\n\t ************************************************************************/\n\n\n\n\t/************************************************************************\n\t * BEGINNING OF -->  Object Enumeration Helpers\n\t */\n\t// fProcessFunction has the following signature:\n\t// (pObjectKey, pObject, pScriptHost, fOperationComplete)\n\tenumerateObjectProperties(pObject, fProcessFunction, fEnumerationComplete, pParallelOperations)\n\t{\n\t\tlet tmpParallelOperations = (typeof(pParallelOperations) == 'number') ? pParallelOperations : 1;\n\t\tlet tmpObjectPropertyKeys = Object.keys(pObject);\n\t\tlet tmpfEnumerationComplete = (typeof(fEnumerationComplete) == 'function') ? fEnumerationComplete : ()=>{};\n\n\t\tlibAsync.eachLimit(tmpObjectPropertyKeys, tmpParallelOperations,\n\t\t\t(tmpKey, fOperationComplete) =>\n\t\t\t{\n\t\t\t\treturn fProcessFunction(tmpKey, pObject[tmpKey], this, fOperationComplete);\n\t\t\t}, tmpfEnumerationComplete);\n\t}\n\n\tenumerateArrayEntries(pArray, fProcessFunction, fEnumerationComplete, pParallelOperations)\n\t{\n\t\tlet tmpParallelOperations = (typeof(pParallelOperations) == 'number') ? pParallelOperations : 1;\n\t\tlet tmpfEnumerationComplete = (typeof(fEnumerationComplete) == 'function') ? fEnumerationComplete : ()=>{};\n\n\t\tlibAsync.eachLimit(pArray, tmpParallelOperations,\n\t\t\t(tmpEntry, fOperationComplete) =>\n\t\t\t{\n\t\t\t\treturn fProcessFunction(tmpKey, tmpEntry, this, fOperationComplete);\n\t\t\t}, tmpfEnumerationComplete);\n\t}\n\t/*\n\t * END OF       -->  Object Enumeration Helpers\n\t ************************************************************************/\n}\n\nmodule.exports = Choreographic;\n\n}).call(this)}).call(this,require('_process'))\n\n},{\"_process\":34,\"fable\":30,\"fs\":17}]},{},[36])(36)\n});\n\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _eachOfLimit = require('./internal/eachOfLimit.js');\n\nvar _eachOfLimit2 = _interopRequireDefault(_eachOfLimit);\n\nvar _withoutIndex = require('./internal/withoutIndex.js');\n\nvar _withoutIndex2 = _interopRequireDefault(_withoutIndex);\n\nvar _wrapAsync = require('./internal/wrapAsync.js');\n\nvar _wrapAsync2 = _interopRequireDefault(_wrapAsync);\n\nvar _awaitify = require('./internal/awaitify.js');\n\nvar _awaitify2 = _interopRequireDefault(_awaitify);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * The same as [`each`]{@link module:Collections.each} but runs a maximum of `limit` async operations at a time.\n *\n * @name eachLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.each]{@link module:Collections.each}\n * @alias forEachLimit\n * @category Collection\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - An async function to apply to each item in\n * `coll`.\n * The array index is not passed to the iteratee.\n * If you need the index, use `eachOfLimit`.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called when all\n * `iteratee` functions have finished, or an error occurs. Invoked with (err).\n * @returns {Promise} a promise, if a callback is omitted\n */\nfunction eachLimit(coll, limit, iteratee, callback) {\n  return (0, _eachOfLimit2.default)(limit)(coll, (0, _withoutIndex2.default)((0, _wrapAsync2.default)(iteratee)), callback);\n}\nexports.default = (0, _awaitify2.default)(eachLimit, 4);\nmodule.exports = exports['default'];","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = asyncEachOfLimit;\n\nvar _breakLoop = require('./breakLoop.js');\n\nvar _breakLoop2 = _interopRequireDefault(_breakLoop);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// for async generators\nfunction asyncEachOfLimit(generator, limit, iteratee, callback) {\n    let done = false;\n    let canceled = false;\n    let awaiting = false;\n    let running = 0;\n    let idx = 0;\n\n    function replenish() {\n        //console.log('replenish')\n        if (running >= limit || awaiting || done) return;\n        //console.log('replenish awaiting')\n        awaiting = true;\n        generator.next().then(({ value, done: iterDone }) => {\n            //console.log('got value', value)\n            if (canceled || done) return;\n            awaiting = false;\n            if (iterDone) {\n                done = true;\n                if (running <= 0) {\n                    //console.log('done nextCb')\n                    callback(null);\n                }\n                return;\n            }\n            running++;\n            iteratee(value, idx, iterateeCallback);\n            idx++;\n            replenish();\n        }).catch(handleError);\n    }\n\n    function iterateeCallback(err, result) {\n        //console.log('iterateeCallback')\n        running -= 1;\n        if (canceled) return;\n        if (err) return handleError(err);\n\n        if (err === false) {\n            done = true;\n            canceled = true;\n            return;\n        }\n\n        if (result === _breakLoop2.default || done && running <= 0) {\n            done = true;\n            //console.log('done iterCb')\n            return callback(null);\n        }\n        replenish();\n    }\n\n    function handleError(err) {\n        if (canceled) return;\n        awaiting = false;\n        done = true;\n        callback(err);\n    }\n\n    replenish();\n}\nmodule.exports = exports['default'];","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = awaitify;\n// conditionally promisify a function.\n// only return a promise if a callback is omitted\nfunction awaitify(asyncFn, arity = asyncFn.length) {\n    if (!arity) throw new Error('arity is undefined');\n    function awaitable(...args) {\n        if (typeof args[arity - 1] === 'function') {\n            return asyncFn.apply(this, args);\n        }\n\n        return new Promise((resolve, reject) => {\n            args[arity - 1] = (err, ...cbArgs) => {\n                if (err) return reject(err);\n                resolve(cbArgs.length > 1 ? cbArgs : cbArgs[0]);\n            };\n            asyncFn.apply(this, args);\n        });\n    }\n\n    return awaitable;\n}\nmodule.exports = exports['default'];","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n// A temporary value used to identify if the loop should be broken.\n// See #1064, #1293\nconst breakLoop = {};\nexports.default = breakLoop;\nmodule.exports = exports[\"default\"];","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _once = require('./once.js');\n\nvar _once2 = _interopRequireDefault(_once);\n\nvar _iterator = require('./iterator.js');\n\nvar _iterator2 = _interopRequireDefault(_iterator);\n\nvar _onlyOnce = require('./onlyOnce.js');\n\nvar _onlyOnce2 = _interopRequireDefault(_onlyOnce);\n\nvar _wrapAsync = require('./wrapAsync.js');\n\nvar _asyncEachOfLimit = require('./asyncEachOfLimit.js');\n\nvar _asyncEachOfLimit2 = _interopRequireDefault(_asyncEachOfLimit);\n\nvar _breakLoop = require('./breakLoop.js');\n\nvar _breakLoop2 = _interopRequireDefault(_breakLoop);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = limit => {\n    return (obj, iteratee, callback) => {\n        callback = (0, _once2.default)(callback);\n        if (limit <= 0) {\n            throw new RangeError('concurrency limit cannot be less than 1');\n        }\n        if (!obj) {\n            return callback(null);\n        }\n        if ((0, _wrapAsync.isAsyncGenerator)(obj)) {\n            return (0, _asyncEachOfLimit2.default)(obj, limit, iteratee, callback);\n        }\n        if ((0, _wrapAsync.isAsyncIterable)(obj)) {\n            return (0, _asyncEachOfLimit2.default)(obj[Symbol.asyncIterator](), limit, iteratee, callback);\n        }\n        var nextElem = (0, _iterator2.default)(obj);\n        var done = false;\n        var canceled = false;\n        var running = 0;\n        var looping = false;\n\n        function iterateeCallback(err, value) {\n            if (canceled) return;\n            running -= 1;\n            if (err) {\n                done = true;\n                callback(err);\n            } else if (err === false) {\n                done = true;\n                canceled = true;\n            } else if (value === _breakLoop2.default || done && running <= 0) {\n                done = true;\n                return callback(null);\n            } else if (!looping) {\n                replenish();\n            }\n        }\n\n        function replenish() {\n            looping = true;\n            while (running < limit && !done) {\n                var elem = nextElem();\n                if (elem === null) {\n                    done = true;\n                    if (running <= 0) {\n                        callback(null);\n                    }\n                    return;\n                }\n                running += 1;\n                iteratee(elem.value, elem.key, (0, _onlyOnce2.default)(iterateeCallback));\n            }\n            looping = false;\n        }\n\n        replenish();\n    };\n};\n\nmodule.exports = exports['default'];","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nexports.default = function (coll) {\n    return coll[Symbol.iterator] && coll[Symbol.iterator]();\n};\n\nmodule.exports = exports[\"default\"];","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nexports.default = function (fn) {\n    return function (...args /*, callback*/) {\n        var callback = args.pop();\n        return fn.call(this, args, callback);\n    };\n};\n\nmodule.exports = exports[\"default\"];","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = isArrayLike;\nfunction isArrayLike(value) {\n    return value && typeof value.length === 'number' && value.length >= 0 && value.length % 1 === 0;\n}\nmodule.exports = exports['default'];","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = createIterator;\n\nvar _isArrayLike = require('./isArrayLike.js');\n\nvar _isArrayLike2 = _interopRequireDefault(_isArrayLike);\n\nvar _getIterator = require('./getIterator.js');\n\nvar _getIterator2 = _interopRequireDefault(_getIterator);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction createArrayIterator(coll) {\n    var i = -1;\n    var len = coll.length;\n    return function next() {\n        return ++i < len ? { value: coll[i], key: i } : null;\n    };\n}\n\nfunction createES2015Iterator(iterator) {\n    var i = -1;\n    return function next() {\n        var item = iterator.next();\n        if (item.done) return null;\n        i++;\n        return { value: item.value, key: i };\n    };\n}\n\nfunction createObjectIterator(obj) {\n    var okeys = obj ? Object.keys(obj) : [];\n    var i = -1;\n    var len = okeys.length;\n    return function next() {\n        var key = okeys[++i];\n        if (key === '__proto__') {\n            return next();\n        }\n        return i < len ? { value: obj[key], key } : null;\n    };\n}\n\nfunction createIterator(coll) {\n    if ((0, _isArrayLike2.default)(coll)) {\n        return createArrayIterator(coll);\n    }\n\n    var iterator = (0, _getIterator2.default)(coll);\n    return iterator ? createES2015Iterator(iterator) : createObjectIterator(coll);\n}\nmodule.exports = exports['default'];","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = once;\nfunction once(fn) {\n    function wrapper(...args) {\n        if (fn === null) return;\n        var callFn = fn;\n        fn = null;\n        callFn.apply(this, args);\n    }\n    Object.assign(wrapper, fn);\n    return wrapper;\n}\nmodule.exports = exports[\"default\"];","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = onlyOnce;\nfunction onlyOnce(fn) {\n    return function (...args) {\n        if (fn === null) throw new Error(\"Callback was already called.\");\n        var callFn = fn;\n        fn = null;\n        callFn.apply(this, args);\n    };\n}\nmodule.exports = exports[\"default\"];","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.fallback = fallback;\nexports.wrap = wrap;\n/* istanbul ignore file */\n\nvar hasQueueMicrotask = exports.hasQueueMicrotask = typeof queueMicrotask === 'function' && queueMicrotask;\nvar hasSetImmediate = exports.hasSetImmediate = typeof setImmediate === 'function' && setImmediate;\nvar hasNextTick = exports.hasNextTick = typeof process === 'object' && typeof process.nextTick === 'function';\n\nfunction fallback(fn) {\n    setTimeout(fn, 0);\n}\n\nfunction wrap(defer) {\n    return (fn, ...args) => defer(() => fn(...args));\n}\n\nvar _defer;\n\nif (hasQueueMicrotask) {\n    _defer = queueMicrotask;\n} else if (hasSetImmediate) {\n    _defer = setImmediate;\n} else if (hasNextTick) {\n    _defer = process.nextTick;\n} else {\n    _defer = fallback;\n}\n\nexports.default = wrap(_defer);","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = _withoutIndex;\nfunction _withoutIndex(iteratee) {\n    return (value, index, callback) => iteratee(value, callback);\n}\nmodule.exports = exports[\"default\"];","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.isAsyncIterable = exports.isAsyncGenerator = exports.isAsync = undefined;\n\nvar _asyncify = require('../asyncify.js');\n\nvar _asyncify2 = _interopRequireDefault(_asyncify);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction isAsync(fn) {\n    return fn[Symbol.toStringTag] === 'AsyncFunction';\n}\n\nfunction isAsyncGenerator(fn) {\n    return fn[Symbol.toStringTag] === 'AsyncGenerator';\n}\n\nfunction isAsyncIterable(obj) {\n    return typeof obj[Symbol.asyncIterator] === 'function';\n}\n\nfunction wrapAsync(asyncFn) {\n    if (typeof asyncFn !== 'function') throw new Error('expected a function');\n    return isAsync(asyncFn) ? (0, _asyncify2.default)(asyncFn) : asyncFn;\n}\n\nexports.default = wrapAsync;\nexports.isAsync = isAsync;\nexports.isAsyncGenerator = isAsyncGenerator;\nexports.isAsyncIterable = isAsyncIterable;","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _once = require('./internal/once.js');\n\nvar _once2 = _interopRequireDefault(_once);\n\nvar _onlyOnce = require('./internal/onlyOnce.js');\n\nvar _onlyOnce2 = _interopRequireDefault(_onlyOnce);\n\nvar _wrapAsync = require('./internal/wrapAsync.js');\n\nvar _wrapAsync2 = _interopRequireDefault(_wrapAsync);\n\nvar _awaitify = require('./internal/awaitify.js');\n\nvar _awaitify2 = _interopRequireDefault(_awaitify);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Runs the `tasks` array of functions in series, each passing their results to\n * the next in the array. However, if any of the `tasks` pass an error to their\n * own callback, the next function is not executed, and the main `callback` is\n * immediately called with the error.\n *\n * @name waterfall\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Array} tasks - An array of [async functions]{@link AsyncFunction}\n * to run.\n * Each function should complete with any number of `result` values.\n * The `result` values will be passed as arguments, in order, to the next task.\n * @param {Function} [callback] - An optional callback to run once all the\n * functions have completed. This will be passed the results of the last task's\n * callback. Invoked with (err, [results]).\n * @returns {Promise} a promise, if a callback is omitted\n * @example\n *\n * async.waterfall([\n *     function(callback) {\n *         callback(null, 'one', 'two');\n *     },\n *     function(arg1, arg2, callback) {\n *         // arg1 now equals 'one' and arg2 now equals 'two'\n *         callback(null, 'three');\n *     },\n *     function(arg1, callback) {\n *         // arg1 now equals 'three'\n *         callback(null, 'done');\n *     }\n * ], function (err, result) {\n *     // result now equals 'done'\n * });\n *\n * // Or, with named functions:\n * async.waterfall([\n *     myFirstFunction,\n *     mySecondFunction,\n *     myLastFunction,\n * ], function (err, result) {\n *     // result now equals 'done'\n * });\n * function myFirstFunction(callback) {\n *     callback(null, 'one', 'two');\n * }\n * function mySecondFunction(arg1, arg2, callback) {\n *     // arg1 now equals 'one' and arg2 now equals 'two'\n *     callback(null, 'three');\n * }\n * function myLastFunction(arg1, callback) {\n *     // arg1 now equals 'three'\n *     callback(null, 'done');\n * }\n */\nfunction waterfall(tasks, callback) {\n    callback = (0, _once2.default)(callback);\n    if (!Array.isArray(tasks)) return callback(new Error('First argument to waterfall must be an array of functions'));\n    if (!tasks.length) return callback();\n    var taskIndex = 0;\n\n    function nextTask(args) {\n        var task = (0, _wrapAsync2.default)(tasks[taskIndex++]);\n        task(...args, (0, _onlyOnce2.default)(next));\n    }\n\n    function next(err, ...args) {\n        if (err === false) return;\n        if (err || taskIndex === tasks.length) {\n            return callback(err, ...args);\n        }\n        nextTask(args);\n    }\n\n    nextTask([]);\n}\n\nexports.default = (0, _awaitify2.default)(waterfall);\nmodule.exports = exports['default'];","/**\n* Base Logger Class\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n*/\n\nclass BaseLogger\n{\n\tconstructor(pLogStreamSettings, pFableLog)\n\t{\n\t\t// This should not possibly be able to be instantiated without a settings object\n\t\tthis._Settings = (typeof(pLogStreamSettings) == 'object') ? pLogStreamSettings : {};\n\n\t\t// The base logger does nothing but associate a UUID with itself\n\t\t// We added this as the mechanism for tracking loggers to allow multiple simultaneous streams\n\t\t// to the same provider.\n\t\tthis.loggerUUID = this.generateInsecureUUID();\n\n\t\t// Eventually we can use this array to ompute which levels the provider allows.\n\t\t// For now it's just used to precompute some string concatenations.\n\t\tthis.levels = (\n\t\t\t[\n\t\t\t\t\"trace\",\n\t\t\t\t\"debug\",\n\t\t\t\t\"info\",\n\t\t\t\t\"warn\",\n\t\t\t\t\"error\",\n\t\t\t\t\"fatal\"\n\t\t\t]);\n\t}\n\n\t// This is meant to generate programmatically insecure UUIDs to identify loggers\n\tgenerateInsecureUUID()\n\t{\n\t\tlet tmpDate = new Date().getTime();\n\t\tlet tmpUUID = 'LOGSTREAM-xxxxxx-yxxxxx'.replace(/[xy]/g,\n\t\t\t\t(pCharacter) =>\n\t\t\t\t{\n\t\t\t\t\t// Funny algorithm from w3resource that is twister-ish without the deep math and security\n\t\t\t\t\t// ..but good enough for unique log stream identifiers\n\t\t\t\t\tlet tmpRandomData = (tmpDate + Math.random()*16)%16 | 0;\n\t\t\t\t\ttmpDate = Math.floor(tmpDate/16);\n\n\t\t\t\t\treturn (pCharacter =='x' ? tmpRandomData : (tmpRandomData&0x3|0x8)).toString(16);\n\t\t\t\t});\n\t\treturn tmpUUID;\n\t}\n\n\tinitialize()\n\t{\n\t\t// No operation.\n\t}\n\n\ttrace(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"trace\", pLogText, pLogObject);\n\t}\n\n\tdebug(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"debug\", pLogText, pLogObject);\n\t}\n\n\tinfo(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"info\", pLogText, pLogObject);\n\t}\n\n\twarn(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"warn\", pLogText, pLogObject);\n\t}\n\n\terror(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"error\", pLogText, pLogObject);\n\t}\n\n\tfatal(pLogText, pLogObject)\n\t{\n\t\tthis.write(\"fatal\", pLogText, pLogObject);\n\t}\n\n\twrite(pLogLevel, pLogText, pLogObject)\n\t{\n\t\t// The base logger does nothing.\n\t\treturn true;\n\t}\n}\n\nmodule.exports = BaseLogger;\n","/**\n* Default Logger Provider Function\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n*/\n\n// Return the providers that are available without extensions loaded\ngetDefaultProviders = () =>\n{\n\tlet tmpDefaultProviders = {};\n\n\ttmpDefaultProviders.console = require('./Fable-Log-Logger-Console.js');\n\n\ttmpDefaultProviders.default = tmpDefaultProviders.console;\n\n\treturn tmpDefaultProviders;\n}\n\nmodule.exports = getDefaultProviders();","module.exports=[\n    {\n        \"loggertype\": \"console\",\n        \"streamtype\": \"console\",\n        \"level\": \"trace\"\n    }\n]","let libBaseLogger = require('./Fable-Log-BaseLogger.js');\n\nclass ConsoleLogger extends libBaseLogger\n{\n\tconstructor(pLogStreamSettings, pFableLog)\n\t{\n\t\tsuper(pLogStreamSettings);\n\n\t\tthis._ShowTimeStamps = this._Settings.hasOwnProperty('showtimestamps') ? (this._Settings.showtimestamps == true) : false;\n\t\tthis._FormattedTimeStamps = this._Settings.hasOwnProperty('formattedtimestamps') ? (this._Settings.formattedtimestamps == true) : false;\n\n\t\tthis._ContextMessage = this._Settings.hasOwnProperty('Context') ? `(${this._Settings.Context})` : \n\t\t\t\t\t\t\t\tpFableLog._Settings.hasOwnProperty('Product') ? `(${pFableLog._Settings.Product})` :\n\t\t\t\t\t\t\t\t'Unnamed_Log_Context';\n\n\t\t// Allow the user to decide what gets output to the console\n\t\tthis._OutputLogLinesToConsole = this._Settings.hasOwnProperty('outputloglinestoconsole') ? this._Settings.outputloglinestoconsole : true;\n\t\tthis._OutputObjectsToConsole = this._Settings.hasOwnProperty('outputobjectstoconsole') ? this._Settings.outputobjectstoconsole : true;\n\n\t\t// Precompute the prefix for each level\n\t\tthis.prefixCache = {};\n\t\tfor (let i = 0; i <= this.levels.length; i++)\n\t\t{\n\t\t\tthis.prefixCache[this.levels[i]] = `[${this.levels[i]}] ${this._ContextMessage}: `;\n\n\t\t\tif (this._ShowTimeStamps)\n\t\t\t{\n\t\t\t\t// If there is a timestamp we need a to prepend space before the prefixcache string, since the timestamp comes first\n\t\t\t\tthis.prefixCache[this.levels[i]] = ' '+this.prefixCache[this.levels[i]];\n\t\t\t}\n\t\t}\n\t}\n\n\twrite(pLevel, pLogText, pObject)\n\t{\n\t\tlet tmpTimeStamp = '';\n\t\tif (this._ShowTimeStamps && this._FormattedTimeStamps)\n\t\t{\n\t\t\ttmpTimeStamp = (new Date()).toISOString();\n\t\t}\n\t\telse if (this._ShowTimeStamps)\n\t\t{\n\t\t\ttmpTimeStamp = +new Date();\n\t\t}\n\n\t\tlet tmpLogLine = `${tmpTimeStamp}${this.prefixCache[pLevel]}${pLogText}`;\n\n\t\tif (this._OutputLogLinesToConsole)\n\t\t{\n\t\t\tconsole.log(tmpLogLine);\n\t\t}\n\n\t\t// Write out the object on a separate line if it is passed in\n\t\tif (this._OutputObjectsToConsole && (typeof(pObject) !== 'undefined'))\n\t\t{\n\t\t\tconsole.log(JSON.stringify(pObject, null, 2));\n\t\t}\n\n\t\t// Provide an easy way to be overridden and be consistent\n\t\treturn tmpLogLine;\n\t}\n}\n\nmodule.exports = ConsoleLogger;","/**\n* Fable Logging Add-on\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n* @module Fable Logger\n*/\n\n/**\n* Fable Solution Log Wrapper Main Class\n*\n* @class FableLog\n* @constructor\n*/\nclass FableLog\n{\n\tconstructor(pFableSettings, pFable)\n\t{\n\t\tlet tmpSettings = (typeof(pFableSettings) === 'object') ? pFableSettings : {}\n\t\tthis._Settings = tmpSettings;\n\n\t\tthis._Providers = require('./Fable-Log-DefaultProviders-Node.js');\n\n\t\tthis._StreamDefinitions = (tmpSettings.hasOwnProperty('LogStreams')) ? tmpSettings.LogStreams : require('./Fable-Log-DefaultStreams.json');\n\n\t\tthis.logStreams = [];\n\n\t\t// This object gets decorated for one-time instantiated providers that\n\t\t//  have multiple outputs, such as bunyan.\n\t\tthis.logProviders = {};\n\n\t\t// A hash list of the GUIDs for each log stream, so they can't be added to the set more than one time\n\t\tthis.activeLogStreams = {};\n\n\t\tthis.logStreamsTrace = [];\n\t\tthis.logStreamsDebug = [];\n\t\tthis.logStreamsInfo = [];\n\t\tthis.logStreamsWarn = [];\n\t\tthis.logStreamsError = [];\n\t\tthis.logStreamsFatal = [];\n\n\t\tthis.datumDecorator = (pDatum) => pDatum;\n\n\t\tthis.uuid = (typeof(tmpSettings.Product) === 'string') ? tmpSettings.Product : 'Default';\n\t}\n\n\taddLogger(pLogger, pLevel)\n\t{\n\t\t// Bail out if we've already created one.\n\t\tif (this.activeLogStreams.hasOwnProperty(pLogger.loggerUUID))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\t// Add it to the streams and to the mutex\n\t\tthis.logStreams.push(pLogger);\n\t\tthis.activeLogStreams[pLogger.loggerUUID] = true;\n\n\t\t// Make sure a kosher level was passed in\n\t\tswitch (pLevel)\n\t\t{\n\t\t\tcase 'trace':\n\t\t\t\tthis.logStreamsTrace.push(pLogger);\n\t\t\tcase 'debug':\n\t\t\t\tthis.logStreamsDebug.push(pLogger);\n\t\t\tcase 'info':\n\t\t\t\tthis.logStreamsInfo.push(pLogger);\n\t\t\tcase 'warn':\n\t\t\t\tthis.logStreamsWarn.push(pLogger);\n\t\t\tcase 'error':\n\t\t\t\tthis.logStreamsError.push(pLogger);\n\t\t\tcase 'fatal':\n\t\t\t\tthis.logStreamsFatal.push(pLogger);\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tsetDatumDecorator(fDatumDecorator)\n\t{\n\t\tif (typeof(fDatumDecorator) === 'function')\n\t\t{\n\t\t\tthis.datumDecorator = fDatumDecorator;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.datumDecorator = (pDatum) => pDatum;\n\t\t}\n\t}\n\n\ttrace(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsTrace.length; i++)\n\t\t{\n\t\t\tthis.logStreamsTrace[i].trace(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\tdebug(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsDebug.length; i++)\n\t\t{\n\t\t\tthis.logStreamsDebug[i].debug(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\tinfo(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsInfo.length; i++)\n\t\t{\n\t\t\tthis.logStreamsInfo[i].info(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\twarn(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsWarn.length; i++)\n\t\t{\n\t\t\tthis.logStreamsWarn[i].warn(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\terror(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsError.length; i++)\n\t\t{\n\t\t\tthis.logStreamsError[i].error(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\tfatal(pMessage, pDatum)\n\t{\n\t\tconst tmpDecoratedDatum = this.datumDecorator(pDatum);\n\t\tfor (let i = 0; i < this.logStreamsFatal.length; i++)\n\t\t{\n\t\t\tthis.logStreamsFatal[i].fatal(pMessage, tmpDecoratedDatum);\n\t\t}\n\t}\n\n\tinitialize()\n\t{\n\t\t// \"initialize\" each logger as defined in the logging parameters\n\t\tfor (let i = 0; i < this._StreamDefinitions.length; i++)\n\t\t{\n\t\t\tlet tmpStreamDefinition = Object.assign({loggertype:'default',streamtype:'console',level:'info'},this._StreamDefinitions[i]);\n\n\t\t\tif (!this._Providers.hasOwnProperty(tmpStreamDefinition.loggertype))\n\t\t\t{\n\t\t\t\tconsole.log(`Error initializing log stream: bad loggertype in stream definition ${JSON.stringify(tmpStreamDefinition)}`);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.addLogger(new this._Providers[tmpStreamDefinition.loggertype](tmpStreamDefinition, this), tmpStreamDefinition.level);\n\t\t\t}\n\t\t}\n\n\t\t// Now initialize each one.\n\t\tfor (let i = 0; i < this.logStreams.length; i++)\n\t\t{\n\t\t\tthis.logStreams[i].initialize();\n\t\t}\n\t}\n\n\tlogTime(pMessage, pDatum)\n\t{\n\t\tlet tmpMessage = (typeof(pMessage) !== 'undefined') ? pMessage : 'Time';\n\t\tlet tmpTime = new Date();\n\t\tthis.info(`${tmpMessage} ${tmpTime} (epoch ${+tmpTime})`, pDatum);\n\t}\n\n\t// Get a timestamp\n\tgetTimeStamp()\n\t{\n\t\treturn +new Date();\n\t}\n\n\tgetTimeDelta(pTimeStamp)\n\t{\n\t\tlet tmpEndTime = +new Date();\n\t\treturn tmpEndTime-pTimeStamp;\n\t}\n\n\t// Log the delta between a timestamp, and now with a message\n\tlogTimeDelta(pTimeDelta, pMessage, pDatum)\n\t{\n\t\tlet tmpMessage = (typeof(pMessage) !== 'undefined') ? pMessage : 'Time Measurement';\n\t\tlet tmpDatum = (typeof(pDatum) === 'object') ? pDatum : {};\n\n\t\tlet tmpEndTime = +new Date();\n\n\t\tthis.info(`${tmpMessage} logged at (epoch ${+tmpEndTime}) took (${pTimeDelta}ms)`, pDatum);\n\t}\n\n\tlogTimeDeltaHuman(pTimeDelta, pMessage, pDatum)\n\t{\n\t\tlet tmpMessage = (typeof(pMessage) !== 'undefined') ? pMessage : 'Time Measurement';\n\n\t\tlet tmpEndTime = +new Date();\n\n\t\tlet tmpMs = parseInt(pTimeDelta%1000);\n\t\tlet tmpSeconds = parseInt((pTimeDelta/1000)%60);\n\t\tlet tmpMinutes = parseInt((pTimeDelta/(1000*60))%60);\n\t\tlet tmpHours = parseInt(pTimeDelta/(1000*60*60));\n\n\t\ttmpMs = (tmpMs < 10) ? \"00\"+tmpMs : (tmpMs < 100) ? \"0\"+tmpMs : tmpMs;\n\t\ttmpSeconds = (tmpSeconds < 10) ? \"0\"+tmpSeconds : tmpSeconds;\n\t\ttmpMinutes = (tmpMinutes < 10) ? \"0\"+tmpMinutes : tmpMinutes;\n\t\ttmpHours = (tmpHours < 10) ? \"0\"+tmpHours : tmpHours;\n\n\t\tthis.info(`${tmpMessage} logged at (epoch ${+tmpEndTime}) took (${pTimeDelta}ms) or (${tmpHours}:${tmpMinutes}:${tmpSeconds}.${tmpMs})`, pDatum);\n\t}\n\n\tlogTimeDeltaRelative(pStartTime, pMessage, pDatum)\n\t{\n\t\tthis.logTimeDelta(this.getTimeDelta(pStartTime), pMessage, pDatum);\n\t}\n\n\tlogTimeDeltaRelativeHuman(pStartTime, pMessage, pDatum)\n\t{\n\t\tthis.logTimeDeltaHuman(this.getTimeDelta(pStartTime), pMessage, pDatum);\n\t}\n}\n\n// This is for backwards compatibility\nfunction autoConstruct(pSettings)\n{\n\treturn new FableLog(pSettings);\n}\n\n\nmodule.exports = FableLog;\nmodule.exports.new = autoConstruct;\nmodule.exports.LogProviderBase = require('./Fable-Log-BaseLogger.js');\n","module.exports={\n\t\"Product\": \"ApplicationNameHere\",\n\t\"ProductVersion\": \"0.0.0\",\n\n\t\"ConfigFile\": false,\n\n\t\"LogStreams\":\n\t[\n\t\t{\n\t\t\t\"level\": \"trace\"\n\t\t}\n\t]\n}\n","/**\n* Fable Settings Template Processor\n*\n* This class allows environment variables to come in via templated expressions, and defaults to be set.\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n* @module Fable Settings\n*/\n\nclass FableSettingsTemplateProcessor\n{\n\tconstructor(pDependencies)\n\t{\n        // Use a no-dependencies templating engine to parse out environment variables\n\t\tthis.templateProcessor = new pDependencies.precedent();\n\n        // TODO: Make the environment variable wrap expression demarcation characters configurable?\n\t\tthis.templateProcessor.addPattern('${', '}',\n\t\t\t(pTemplateValue)=>\n\t\t\t{\n\t\t\t\tlet tmpTemplateValue = pTemplateValue.trim();\n\n\t\t\t\tlet tmpSeparatorIndex = tmpTemplateValue.indexOf('|');\n\n\t\t\t\t// If there is no pipe, the default value will end up being whatever the variable name is.\n\t\t\t\tlet tmpDefaultValue = tmpTemplateValue.substring(tmpSeparatorIndex+1);\n\n\t\t\t\tlet tmpEnvironmentVariableName = (tmpSeparatorIndex > -1) ? tmpTemplateValue.substring(0, tmpSeparatorIndex) : tmpTemplateValue;\n\n\t\t\t\tif (process.env.hasOwnProperty(tmpEnvironmentVariableName))\n\t\t\t\t{\n\t\t\t\t\treturn process.env[tmpEnvironmentVariableName];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\treturn tmpDefaultValue;\n\t\t\t\t}\n\t\t\t});\n    }\n\n    parseSetting(pString)\n    {\n        return this.templateProcessor.parseString(pString);\n    }\n}\n\nmodule.exports = FableSettingsTemplateProcessor;","/**\n* Fable Settings Add-on\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n* @module Fable Settings\n*/\n\nconst libPrecedent = require('precedent');\nconst libFableSettingsTemplateProcessor = require('./Fable-Settings-TemplateProcessor.js');\n\nclass FableSettings\n{\n\tconstructor(pFableSettings)\n\t{\n\t\t// Expose the dependencies for downstream re-use\n\t\tthis.dependencies = (\n\t\t\t{\n\t\t\t\tprecedent: libPrecedent\n\t\t\t});\n\n\t\t// Initialize the settings value template processor\n\t\tthis.settingsTemplateProcessor = new libFableSettingsTemplateProcessor(this.dependencies);\n\n\t\t// set straight away so anything that uses it respects the initial setting\n\t\tthis._configureEnvTemplating(pFableSettings);\n\n\t\tthis.default = this.buildDefaultSettings();\n\n\t\t// Construct a new settings object\n\t\tlet tmpSettings = this.merge(pFableSettings, this.buildDefaultSettings());\n\n\t\t// The base settings object (what they were on initialization, before other actors have altered them)\n\t\tthis.base = JSON.parse(JSON.stringify(tmpSettings));\n\n\t\tif (tmpSettings.DefaultConfigFile)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\t// If there is a DEFAULT configuration file, try to load and merge it.\n\t\t\t\ttmpSettings = this.merge(require(tmpSettings.DefaultConfigFile), tmpSettings);\n\t\t\t}\n\t\t\tcatch (pException)\n\t\t\t{\n\t\t\t\t// Why this?  Often for an app we want settings to work out of the box, but\n\t\t\t\t// would potentially want to have a config file for complex settings.\n\t\t\t\tconsole.log('Fable-Settings Warning: Default configuration file specified but there was a problem loading it.  Falling back to base.');\n\t\t\t\tconsole.log('     Loading Exception: '+pException);\n\t\t\t}\n\t\t}\n\n\t\tif (tmpSettings.ConfigFile)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\t// If there is a configuration file, try to load and merge it.\n\t\t\t\ttmpSettings = this.merge(require(tmpSettings.ConfigFile), tmpSettings);\n\t\t\t}\n\t\t\tcatch (pException)\n\t\t\t{\n\t\t\t\t// Why this?  Often for an app we want settings to work out of the box, but\n\t\t\t\t// would potentially want to have a config file for complex settings.\n\t\t\t\tconsole.log('Fable-Settings Warning: Configuration file specified but there was a problem loading it.  Falling back to base.');\n\t\t\t\tconsole.log('     Loading Exception: '+pException);\n\t\t\t}\n\t\t}\n\n\t\tthis.settings = tmpSettings;\n\t}\n\n\t// Build a default settings object.  Use the JSON jimmy to ensure it is always a new object.\n\tbuildDefaultSettings()\n\t{\n\t\treturn JSON.parse(JSON.stringify(require('./Fable-Settings-Default')));\n\t}\n\n\t// Update the configuration for environment variable templating based on the current settings object\n\t_configureEnvTemplating(pSettings)\n\t{\n\t\t// default environment variable templating to on\n\t\tthis._PerformEnvTemplating = !pSettings || pSettings.NoEnvReplacement !== true;\n\t}\n\n\t// Resolve (recursive) any environment variables found in settings object.\n\t_resolveEnv(pSettings)\n\t{\n\t\tfor (const tmpKey in pSettings)\n\t\t{\n\t\t\tif (typeof(pSettings[tmpKey]) === 'object')\n\t\t\t{\n\t\t\t\tthis._resolveEnv(pSettings[tmpKey]);\n\t\t\t}\n\t\t\telse if (typeof(pSettings[tmpKey]) === 'string')\n\t\t\t{\n\t\t\t\tpSettings[tmpKey] = this.settingsTemplateProcessor.parseSetting(pSettings[tmpKey]);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Check to see if a value is an object (but not an array).\n\t */\n\t_isObject(value)\n\t{\n\t\treturn typeof(value) === 'object' && !Array.isArray(value);\n\t}\n\n\t/**\n\t * Merge two plain objects. Keys that are objects in both will be merged property-wise.\n\t */\n\t_deepMergeObjects(toObject, fromObject)\n\t{\n\t\tif (!fromObject || !this._isObject(fromObject))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tObject.keys(fromObject).forEach((key) =>\n\t\t{\n\t\t\tconst fromValue = fromObject[key];\n\t\t\tif (this._isObject(fromValue))\n\t\t\t{\n\t\t\t\tconst toValue = toObject[key];\n\t\t\t\tif (toValue && this._isObject(toValue))\n\t\t\t\t{\n\t\t\t\t\t// both are objects, so do a recursive merge\n\t\t\t\t\tthis._deepMergeObjects(toValue, fromValue);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttoObject[key] = fromValue;\n\t\t});\n\t\treturn toObject;\n\t}\n\n\t// Merge some new object into the existing settings.\n\tmerge(pSettingsFrom, pSettingsTo)\n\t{\n\t\t// If an invalid settings from object is passed in (e.g. object constructor without passing in anything) this should still work\n\t\tlet tmpSettingsFrom = (typeof(pSettingsFrom) === 'object') ? pSettingsFrom : {};\n\t\t// Default to the settings object if none is passed in for the merge.\n\t\tlet tmpSettingsTo = (typeof(pSettingsTo) === 'object') ? pSettingsTo : this.settings;\n\n\t\t// do not mutate the From object property values\n\t\tlet tmpSettingsFromCopy = JSON.parse(JSON.stringify(tmpSettingsFrom));\n\t\ttmpSettingsTo = this._deepMergeObjects(tmpSettingsTo, tmpSettingsFromCopy);\n\n\t\tif (this._PerformEnvTemplating)\n\t\t{\n\t\t\tthis._resolveEnv(tmpSettingsTo);\n\t\t}\n\t\t// Update env tempating config, since we just updated the config object, and it may have changed\n\t\tthis._configureEnvTemplating(tmpSettingsTo);\n\n\t\treturn tmpSettingsTo;\n\t}\n\n\t// Fill in settings gaps without overwriting settings that are already there\n\tfill(pSettingsFrom)\n\t{\n\t\t// If an invalid settings from object is passed in (e.g. object constructor without passing in anything) this should still work\n\t\tlet tmpSettingsFrom = (typeof(pSettingsFrom) === 'object') ? pSettingsFrom : {};\n\n\t\t// do not mutate the From object property values\n\t\tlet tmpSettingsFromCopy = JSON.parse(JSON.stringify(tmpSettingsFrom));\n\n\t\tthis.settings = this._deepMergeObjects(tmpSettingsFromCopy, this.settings);\n\n\t\treturn this.settings;\n\t}\n};\n\n// This is for backwards compatibility\nfunction autoConstruct(pSettings)\n{\n\treturn new FableSettings(pSettings);\n}\n\nmodule.exports = FableSettings;\nmodule.exports.new = autoConstruct;\nmodule.exports.precedent = libPrecedent;","/**\n* Random Byte Generator - Browser version\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n*/\n\n// Adapted from node-uuid (https://github.com/kelektiv/node-uuid)\n// Unique ID creation requires a high quality random # generator.  In the\n// browser this is a little complicated due to unknown quality of Math.random()\n// and inconsistent support for the `crypto` API.  We do the best we can via\n// feature-detection\nclass RandomBytes\n{\n\tconstructor()\n\t{\n\n\t\t// getRandomValues needs to be invoked in a context where \"this\" is a Crypto\n\t\t// implementation. Also, find the complete implementation of crypto on IE11.\n\t\tthis.getRandomValues = (typeof(crypto) != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto)) ||\n                      \t\t(typeof(msCrypto) != 'undefined' && typeof window.msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto));\n\t}\n\n\t// WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto\n\tgenerateWhatWGBytes()\n\t{\n\t\tlet tmpBuffer = new Uint8Array(16); // eslint-disable-line no-undef\n\n\t\tthis.getRandomValues(tmpBuffer);\n\t\treturn tmpBuffer;\n\t}\n\n\t// Math.random()-based (RNG)\n\tgenerateRandomBytes()\n\t{\n\t\t// If all else fails, use Math.random().  It's fast, but is of unspecified\n\t\t// quality.\n\t\tlet tmpBuffer = new Uint8Array(16); // eslint-disable-line no-undef\n\n\t\tfor (let i = 0, tmpValue; i < 16; i++)\n\t\t{\n\t\t\tif ((i & 0x03) === 0)\n\t\t\t{\n\t\t\t\ttmpValue = Math.random() * 0x100000000;\n\t\t\t}\n\n\t\t\ttmpBuffer[i] = tmpValue >>> ((i & 0x03) << 3) & 0xff;\n\t\t}\n\n\t\treturn tmpBuffer;\n\t}\n\n\tgenerate()\n\t{\n\t\tif (this.getRandomValues)\n\t\t{\n\t\t\treturn this.generateWhatWGBytes();\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn this.generateRandomBytes();\n\t\t}\n\t}\n}\n\nmodule.exports = RandomBytes;\n","/**\n* Fable UUID Generator\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n* @module Fable UUID\n*/\n\n/**\n* Fable Solution UUID Generation Main Class\n*\n* @class FableUUID\n* @constructor\n*/\n\nvar libRandomByteGenerator = require('./Fable-UUID-Random.js')\n\nclass FableUUID\n{\n\tconstructor(pSettings)\n\t{\n\t\t// Determine if the module is in \"Random UUID Mode\" which means just use the random character function rather than the v4 random UUID spec.\n\t\t// Note this allows UUIDs of various lengths (including very short ones) although guaranteed uniqueness goes downhill fast.\n\t\tthis._UUIDModeRandom = (typeof(pSettings) === 'object') && (pSettings.hasOwnProperty('UUIDModeRandom')) ? (pSettings.UUIDModeRandom == true) : false;\n\t\t// These two properties are only useful if we are in Random mode.  Otherwise it generates a v4 spec\n\t\t// Length for \"Random UUID Mode\" is set -- if not set it to 8\n\t\tthis._UUIDLength = (typeof(pSettings) === 'object') && (pSettings.hasOwnProperty('UUIDLength')) ? (pSettings.UUIDLength + 0) : 8;\n\t\t// Dictionary for \"Random UUID Mode\"\n\t\tthis._UUIDRandomDictionary = (typeof(pSettings) === 'object') && (pSettings.hasOwnProperty('UUIDDictionary')) ? (pSettings.UUIDDictionary + 0) : '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';\n\n\t\tthis.randomByteGenerator = new libRandomByteGenerator();\n\n\t\t// Lookup table for hex codes\n\t\tthis._HexLookup = [];\n\t\tfor (let i = 0; i < 256; ++i)\n\t\t{\n\t\t\tthis._HexLookup[i] = (i + 0x100).toString(16).substr(1);\n\t\t}\n\t}\n\n\t// Adapted from node-uuid (https://github.com/kelektiv/node-uuid)\n\tbytesToUUID(pBuffer)\n\t{\n\t\tlet i = 0;\n\t\t// join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4\n\t\treturn ([\n\t\t\t\t\tthis._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], \n\t\t\t\t\tthis._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], '-',\n\t\t\t\t\tthis._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], '-',\n\t\t\t\t\tthis._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], '-',\n\t\t\t\t\tthis._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], '-',\n\t\t\t\t\tthis._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]], this._HexLookup[pBuffer[i++]]\n\t\t\t\t]).join('');\n\t}\n\n\t// Adapted from node-uuid (https://github.com/kelektiv/node-uuid)\n\tgenerateUUIDv4()\n\t{\n\t\tlet tmpBuffer = new Array(16);\n\t\tvar tmpRandomBytes = this.randomByteGenerator.generate();\n\n\t\t// Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\t\ttmpRandomBytes[6] = (tmpRandomBytes[6] & 0x0f) | 0x40;\n\t\ttmpRandomBytes[8] = (tmpRandomBytes[8] & 0x3f) | 0x80;\n\n\t\treturn this.bytesToUUID(tmpRandomBytes);\n\t}\n\n\t// Simple random UUID generation\n\tgenerateRandom()\n\t{\n\t\tlet tmpUUID = '';\n\n\t\tfor (let i = 0; i < this._UUIDLength; i++)\n\t\t{\n\t\t\ttmpUUID += this._UUIDRandomDictionary.charAt(Math.floor(Math.random() * (this._UUIDRandomDictionary.length-1)));\n\t\t}\n\n\t\treturn tmpUUID;\n\t}\n\n\t// Adapted from node-uuid (https://github.com/kelektiv/node-uuid)\n\tgetUUID()\n\t{\n\t\tif (this._UUIDModeRandom)\n\t\t{\n\t\t\treturn this.generateRandom();\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn this.generateUUIDv4();\n\t\t}\n\t}\n}\n\n// This is for backwards compatibility\nfunction autoConstruct(pSettings)\n{\n\treturn new FableUUID(pSettings);\n}\n\n\nmodule.exports = FableUUID;\nmodule.exports.new = autoConstruct;\n","class FableUtility\n{\n\t// Underscore and lodash have a behavior, _.template, which compiles a\n\t// string-based template with code snippets into simple executable pieces,\n\t// with the added twist of returning a precompiled function ready to go.\n\t//\n\t// NOTE: This does not implement underscore escape expressions\n\t// NOTE: This does not implement underscore magic browser variable assignment\n\t//\n\t// This is an implementation of that.\n\t// TODO: Make this use precedent, add configuration, add debugging.\n\tconstructor(pFable, pTemplateText)\n\t{\n\t\tthis.fable = pFable;\n\n\t\t// These are the exact regex's used in lodash/underscore\n\t\t// TODO: Switch this to precedent\n\t\tthis.Matchers = (\n\t\t\t{\n\t\t        Evaluate: /<%([\\s\\S]+?)%>/g,\n\t\t        Interpolate: /<%=([\\s\\S]+?)%>/g,\n\t    \t\tEscaper: /\\\\|'|\\r|\\n|\\t|\\u2028|\\u2029/g,\n\t    \t\tUnescaper: /\\\\(\\\\|'|r|n|t|u2028|u2029)/g,\n\t\t\t\t// This is how underscore does it, so we are keeping it for now.\n\t    \t\tGuaranteedNonMatch: /.^/\n\t\t    });\n\n\t    // This is a helper for the escaper and unescaper functions.\n\t    // Right now we are going to keep what underscore is doing, but, not forever.\n\t    this.templateEscapes = {\n\t        '\\\\': '\\\\',\n\t        \"'\": \"'\",\n\t        'r': '\\r',\n\t        '\\r': 'r',\n\t        'n': '\\n',\n\t        '\\n': 'n',\n\t        't': '\\t',\n\t        '\\t': 't',\n\t        'u2028': '\\u2028',\n\t        '\\u2028': 'u2028',\n\t        'u2029': '\\u2029',\n\t        '\\u2029': 'u2029'\n\t    };\n\n\t    // This is defined as such to underscore that it is a dynamic programming\n\t    // function on this class.\n\t    this.renderFunction = ()=>{return ``};\n\t}\n\n\t// Underscore and lodash have a behavior, _.extend, which merges objects.\n\t// Now that es6 gives us this, use the native thingy.\n\textend(pDestinationObject, ...pSourceObjects)\n\t{\n\t\treturn Object.assign(pDestinationObject, ...pSourceObjects);\n\t}\n\n\trenderTemplate(pData)\n\t{\n\t\treturn this.renderFunction(pData);\n\t}\n\n\ttemplateFunction(pData)\n\t{\n\t\tlet fRenderTemplateBound = this.renderTemplate.bind(this);\n\t\treturn fRenderTemplateBound;\n\t}\n\n\tbuildTemplateFunction(pTemplateText, pData)\n    {\n    \t// For now this is being kept in a weird form ... this is to mimic the old\n    \t// underscore code until this is rewritten using precedent.\n        this.TemplateSource = \"__p+='\" + pTemplateText\n            .replace(this.Matchers.Escaper,\n            \t(pMatch)=>\n\t            {\n\t                return `\\\\${this.templateEscapes[pMatch]}`;\n\t            })\n            .replace(this.Matchers.Interpolate || this.Matchers.GuaranteedNonMatch,\n            \t(pMatch, pCode) =>\n            \t{\n\t                return `'+\\n(${decodeURIComponent(pCode)})+\\n'`;\n\t            })\n\t        .replace(this.Matchers.Evaluate || this.Matchers.GuaranteedNonMatch,\n\t\t\t\t(pMatch, pCode) =>\n            \t{\n\t                return `';\\n${decodeURIComponent(pCode)}\\n;__p+='`;\n\t            }) + `';\\n`;\n\n\n        this.TemplateSource = `with(pTemplateDataObject||{}){\\n${this.TemplateSource}}\\n`;\n        this.TemplateSource = `var __p='';var print=function(){__p+=Array.prototype.join.call(arguments, '')};\\n${this.TemplateSource}return __p;\\n`;\n\n        this.renderFunction = new Function('pTemplateDataObject', this.TemplateSource);\n\n        if (typeof(pData) != 'undefined')\n        {\n            return this.renderFunction(pData);\n        }\n\n        // Provide the compiled function source as a convenience for build time\n        // precompilation.\n        this.TemplateSourceCompiled = 'function(obj){\\n' + this.TemplateSource + '}';\n\n        return this.templateFunction();\n\t}\n}\n\nmodule.exports = FableUtility;","const libFableUtilityTemplate = require('./Fable-Utility-Template.js');\nconst libAsyncWaterfall = require('async/waterfall');\nconst libAsyncEachLimit = require('async/eachLimit');\n\nclass FableUtility\n{\n\tconstructor(pFable)\n\t{\n\t\tthis.fable = pFable;\n\n\t\t// These two functions are used extensively throughout\n\t\tthis.waterfall = libAsyncWaterfall;\n\t\tthis.eachLimit = libAsyncEachLimit;\n\t}\n\n\t// Underscore and lodash have a behavior, _.extend, which merges objects.\n\t// Now that es6 gives us this, use the native thingy.\n\textend(pDestinationObject, ...pSourceObjects)\n\t{\n\t\treturn Object.assign(pDestinationObject, ...pSourceObjects);\n\t}\n\n\t// Underscore and lodash have a behavior, _.template, which compiles a\n\t// string-based template with code snippets into simple executable pieces,\n\t// with the added twist of returning a precompiled function ready to go.\n\ttemplate(pTemplateText, pData)\n\t{\n\t\tlet tmpTemplate = new libFableUtilityTemplate(this.fable, pTemplateText);\n\n\t\treturn tmpTemplate.buildTemplateFunction(pTemplateText, pData);\n\t}\n\n\t// This is a safe, modern version of chunk from underscore\n\t// Algorithm pulled from a mix of these two polyfills:\n\t// https://github.com/you-dont-need/You-Dont-Need-Lodash-Underscore#_chunk\n\t// https://youmightnotneed.com/lodash\n\t// This implementation was most tolerant in browsers.  Uglify can fix the rest.\n\tchunk (pInput, pChunkSize, pChunkCache)\n\t{\n\t\tlet tmpInputArray = [...pInput];\n\t\t// Note lodash defaults to 1, underscore defaults to 0\n\t\tlet tmpChunkSize = (typeof(pChunkSize) == 'number') ? pChunkSize : 0;\n\t\tlet tmpChunkCache = (typeof(pChunkCache) != 'undefined') ? pChunkCache : [];\n\n\t\tif (tmpChunkSize <= 0)\n\t\t{\n\t\t\treturn tmpChunkCache;\n\t\t}\n\n\t\twhile (tmpInputArray.length)\n\t\t{\n\t\t\ttmpChunkCache.push(tmpInputArray.splice(0, tmpChunkSize));\n\t\t}\n\n\t\treturn tmpChunkCache;\n\t}\n}\n\nmodule.exports = FableUtility;","/**\n* Fable Application Services Support Library\n* @license MIT\n* @author <steven@velozo.com>\n*/\nconst libFableSettings = require('fable-settings');\nconst libFableUUID = require('fable-uuid');\nconst libFableLog = require('fable-log');\n\nconst libFableUtility = require('./Fable-Utility.js')\n\nclass Fable\n{\n\tconstructor(pSettings)\n\t{\n\t\tlet tmpSettings = new libFableSettings(pSettings);\n\n\t\tthis.settingsManager = tmpSettings;\n\n\t\t// Instantiate the UUID generator\n\t\tthis.libUUID = new libFableUUID(this.settingsManager.settings);\n\n\t\tthis.log = new libFableLog(this.settingsManager.settings);\n\t\tthis.log.initialize();\n\n\t\tthis.Utility = new libFableUtility(this);\n\n\t\t// Built-in dependencies ... more can be added here.\n\t\tthis.Dependencies = (\n\t\t\t{\n\t\t\t\tprecedent: libFableSettings.precedent\n\t\t\t});\n\t}\n\n\tget settings()\n\t{\n\t\treturn this.settingsManager.settings;\n\t}\n\n\tget fable()\n\t{\n\t\treturn this;\n\t}\n\n\tgetUUID()\n\t{\n\t\treturn this.libUUID.getUUID();\n\t}\n}\n\n// This is for backwards compatibility\nfunction autoConstruct(pSettings)\n{\n\treturn new Fable(pSettings);\n}\n\nmodule.exports = Fable;\nmodule.exports.new = autoConstruct;\n\nmodule.exports.LogProviderBase = libFableLog.LogProviderBase;\n\nmodule.exports.precedent = libFableSettings.precedent;","/**\n* Precedent Meta-Templating\n*\n* @license     MIT\n*\n* @author      Steven Velozo <steven@velozo.com>\n*\n* @description Process text streams, parsing out meta-template expressions.\n*/\nvar libWordTree = require(`./WordTree.js`);\nvar libStringParser = require(`./StringParser.js`);\n\nclass Precedent\n{\n\t/**\n\t * Precedent Constructor\n\t */\n\tconstructor()\n\t{\n\t\tthis.WordTree = new libWordTree();\n\t\t\n\t\tthis.StringParser = new libStringParser();\n\n\t\tthis.ParseTree = this.WordTree.ParseTree;\n\t}\n\t\n\t/**\n\t * Add a Pattern to the Parse Tree\n\t * @method addPattern\n\t * @param {Object} pTree - A node on the parse tree to push the characters into\n\t * @param {string} pPattern - The string to add to the tree\n\t * @param {number} pIndex - callback function\n\t * @return {bool} True if adding the pattern was successful\n\t */\n\taddPattern(pPatternStart, pPatternEnd, pParser)\n\t{\n\t\treturn this.WordTree.addPattern(pPatternStart, pPatternEnd, pParser);\n\t}\n\t\n\t/**\n\t * Parse a string with the existing parse tree\n\t * @method parseString\n\t * @param {string} pString - The string to parse\n\t * @return {string} The result from the parser\n\t */\n\tparseString(pString)\n\t{\n\t\treturn this.StringParser.parseString(pString, this.ParseTree);\n\t}\n}\n\nmodule.exports = Precedent;\n","/**\n* String Parser\n*\n* @license     MIT\n*\n* @author      Steven Velozo <steven@velozo.com>\n*\n* @description Parse a string, properly processing each matched token in the word tree.\n*/\n\nclass StringParser\n{\n\t/**\n\t * StringParser Constructor\n\t */\n\tconstructor()\n\t{\n\t}\n\t\n\t/**\n\t * Create a fresh parsing state object to work with.\n\t * @method newParserState\n\t * @param {Object} pParseTree - A node on the parse tree to begin parsing from (usually root)\n\t * @return {Object} A new parser state object for running a character parser on\n\t * @private\n\t */\n\tnewParserState (pParseTree)\n\t{\n\t\treturn (\n\t\t{\n\t\t\tParseTree: pParseTree,\n\n\t\t\tOutput: '',\n\t\t\tOutputBuffer: '',\n\n\t\t\tPattern: false,\n\n\t\t\tPatternMatch: false,\n\t\t\tPatternMatchOutputBuffer: ''\n\t\t});\n\t}\n\t\t\n\t/**\n\t * Assign a node of the parser tree to be the next potential match.\n\t * If the node has a PatternEnd property, it is a valid match and supercedes the last valid match (or becomes the initial match).\n\t * @method assignNode\n\t * @param {Object} pNode - A node on the parse tree to assign\n\t * @param {Object} pParserState - The state object for the current parsing task\n\t * @private\n\t */\n\tassignNode (pNode, pParserState)\n\t{\n\t\tpParserState.PatternMatch = pNode;\n\n\t\t// If the pattern has a END we can assume it has a parse function...\n\t\tif (pParserState.PatternMatch.hasOwnProperty('PatternEnd'))\n\t\t{\n\t\t\t// ... this is the legitimate start of a pattern.\n\t\t\tpParserState.Pattern = pParserState.PatternMatch;\n\t\t}\n\t}\n\t\n\t/**\n\t * Append a character to the output buffer in the parser state.\n\t * This output buffer is used when a potential match is being explored, or a match is being explored.\n\t * @method appendOutputBuffer\n\t * @param {string} pCharacter - The character to append\n\t * @param {Object} pParserState - The state object for the current parsing task\n\t * @private\n\t */\n\tappendOutputBuffer (pCharacter, pParserState)\n\t{\n\t\tpParserState.OutputBuffer += pCharacter;\n\t}\n\t\n\t/**\n\t * Flush the output buffer to the output and clear it.\n\t * @method flushOutputBuffer\n\t * @param {Object} pParserState - The state object for the current parsing task\n\t * @private\n\t */\n\tflushOutputBuffer (pParserState)\n\t{\n\t\tpParserState.Output += pParserState.OutputBuffer;\n\t\tpParserState.OutputBuffer = '';\n\t}\n\n\t\n\t/**\n\t * Check if the pattern has ended.  If it has, properly flush the buffer and start looking for new patterns.\n\t * @method checkPatternEnd\n\t * @param {Object} pParserState - The state object for the current parsing task\n\t * @private\n\t */\n\tcheckPatternEnd (pParserState)\n\t{\n\t\tif ((pParserState.OutputBuffer.length >= pParserState.Pattern.PatternEnd.length+pParserState.Pattern.PatternStart.length) && \n\t\t\t(pParserState.OutputBuffer.substr(-pParserState.Pattern.PatternEnd.length) === pParserState.Pattern.PatternEnd))\n\t\t{\n\t\t\t// ... this is the end of a pattern, cut off the end tag and parse it.\n\t\t\t// Trim the start and end tags off the output buffer now\n\t\t\tpParserState.OutputBuffer = pParserState.Pattern.Parse(pParserState.OutputBuffer.substr(pParserState.Pattern.PatternStart.length, pParserState.OutputBuffer.length - (pParserState.Pattern.PatternStart.length+pParserState.Pattern.PatternEnd.length)));\n\t\t\t// Flush the output buffer.\n\t\t\tthis.flushOutputBuffer(pParserState);\n\t\t\t// End pattern mode\n\t\t\tpParserState.Pattern = false;\n\t\t\tpParserState.PatternMatch = false;\n\t\t}\n\t}\n\t\n\t/**\n\t * Parse a character in the buffer.\n\t * @method parseCharacter\n\t * @param {string} pCharacter - The character to append\n\t * @param {Object} pParserState - The state object for the current parsing task\n\t * @private\n\t */\n\tparseCharacter (pCharacter, pParserState)\n\t{\n\t\t// (1) If we aren't in a pattern match, and we aren't potentially matching, and this may be the start of a new pattern....\n\t\tif (!pParserState.PatternMatch && pParserState.ParseTree.hasOwnProperty(pCharacter))\n\t\t{\n\t\t\t// ... assign the node as the matched node.\n\t\t\tthis.assignNode(pParserState.ParseTree[pCharacter], pParserState);\n\t\t\tthis.appendOutputBuffer(pCharacter, pParserState);\n\t\t}\n\t\t// (2) If we are in a pattern match (actively seeing if this is part of a new pattern token)\n\t\telse if (pParserState.PatternMatch)\n\t\t{\n\t\t\t// If the pattern has a subpattern with this key\n\t\t\tif (pParserState.PatternMatch.hasOwnProperty(pCharacter))\n\t\t\t{\n\t\t\t\t// Continue matching patterns.\n\t\t\t\tthis.assignNode(pParserState.PatternMatch[pCharacter], pParserState);\n\t\t\t}\n\t\t\tthis.appendOutputBuffer(pCharacter, pParserState);\n\t\t\tif (pParserState.Pattern)\n\t\t\t{\n\t\t\t\t// ... Check if this is the end of the pattern (if we are matching a valid pattern)...\n\t\t\t\tthis.checkPatternEnd(pParserState);\n\t\t\t}\n\t\t}\n\t\t// (3) If we aren't in a pattern match or pattern, and this isn't the start of a new pattern (RAW mode)....\n\t\telse\n\t\t{\n\t\t\tpParserState.Output += pCharacter;\n\t\t}\n\t}\n\t\n\t/**\n\t * Parse a string for matches, and process any template segments that occur.\n\t * @method parseString\n\t * @param {string} pString - The string to parse.\n\t * @param {Object} pParseTree - The parse tree to begin parsing from (usually root)\n\t */\n\tparseString (pString, pParseTree)\n\t{\n\t\tlet tmpParserState = this.newParserState(pParseTree);\n\n\t\tfor (var i = 0; i < pString.length; i++)\n\t\t{\n\t\t\t// TODO: This is not fast.\n\t\t\tthis.parseCharacter(pString[i], tmpParserState);\n\t\t}\n\t\t\n\t\tthis.flushOutputBuffer(tmpParserState);\n\t\t\n\t\treturn tmpParserState.Output;\n\t}\n}\n\nmodule.exports = StringParser;\n","/**\n* Word Tree\n*\n* @license     MIT\n*\n* @author      Steven Velozo <steven@velozo.com>\n*\n* @description Create a tree (directed graph) of Javascript objects, one character per object.\n*/\n\nclass WordTree\n{\n\t/**\n\t * WordTree Constructor\n\t */\n\tconstructor()\n\t{\n\t\tthis.ParseTree = {};\n\t}\n\t\n\t/** \n\t * Add a child character to a Parse Tree node\n\t * @method addChild\n\t * @param {Object} pTree - A parse tree to push the characters into\n\t * @param {string} pPattern - The string to add to the tree\n\t * @param {number} pIndex - The index of the character in the pattern\n\t * @returns {Object} The resulting leaf node that was added (or found)\n\t * @private\n\t */\n\taddChild (pTree, pPattern, pIndex)\n\t{\n\t\tif (!pTree.hasOwnProperty(pPattern[pIndex]))\n\t\t\tpTree[pPattern[pIndex]] = {};\n\t\t\n\t\treturn pTree[pPattern[pIndex]];\n\t}\n\t\n\t/** Add a Pattern to the Parse Tree\n\t * @method addPattern\n\t * @param {Object} pPatternStart - The starting string for the pattern (e.g. \"${\")\n\t * @param {string} pPatternEnd - The ending string for the pattern (e.g. \"}\")\n\t * @param {number} pParser - The function to parse if this is the matched pattern, once the Pattern End is met.  If this is a string, a simple replacement occurs.\n\t * @return {bool} True if adding the pattern was successful\n\t */\n\taddPattern (pPatternStart, pPatternEnd, pParser)\n\t{\n\t\tif (pPatternStart.length < 1)\n\t\t\treturn false;\n\n\t\tif ((typeof(pPatternEnd) === 'string') && (pPatternEnd.length < 1))\n\t\t\treturn false;\n\n\t\tlet tmpLeaf = this.ParseTree;\n\n\t\t// Add the tree of leaves iteratively\n\t\tfor (var i = 0; i < pPatternStart.length; i++)\n\t\t\ttmpLeaf = this.addChild(tmpLeaf, pPatternStart, i);\n\n\t\ttmpLeaf.PatternStart = pPatternStart;\n\t\ttmpLeaf.PatternEnd = ((typeof(pPatternEnd) === 'string') && (pPatternEnd.length > 0)) ? pPatternEnd : pPatternStart;\n\t\ttmpLeaf.Parse = (typeof(pParser) === 'function') ? pParser : \n\t\t\t\t\t\t(typeof(pParser) === 'string') ? () => { return pParser; } :\n\t\t\t\t\t\t(pData) => { return pData; };\n\n\t\treturn true;\n\t}\n}\n\nmodule.exports = WordTree;\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","var nextTick = require('process/browser.js').nextTick;\nvar apply = Function.prototype.apply;\nvar slice = Array.prototype.slice;\nvar immediateIds = {};\nvar nextImmediateId = 0;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) { timeout.close(); };\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(window, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// That's not how node.js implements it but the exposed api is the same.\nexports.setImmediate = typeof setImmediate === \"function\" ? setImmediate : function(fn) {\n  var id = nextImmediateId++;\n  var args = arguments.length < 2 ? false : slice.call(arguments, 1);\n\n  immediateIds[id] = true;\n\n  nextTick(function onNextTick() {\n    if (immediateIds[id]) {\n      // fn.call() is faster so we optimize for the common use-case\n      // @see http://jsperf.com/call-apply-segu\n      if (args) {\n        fn.apply(null, args);\n      } else {\n        fn.call(null);\n      }\n      // Prevent ids from leaking\n      exports.clearImmediate(id);\n    }\n  });\n\n  return id;\n};\n\nexports.clearImmediate = typeof clearImmediate === \"function\" ? clearImmediate : function(id) {\n  delete immediateIds[id];\n};","/**\n* @license MIT\n* @author <steven@velozo.com>\n*/\n\n/**\n* Choreographic browser shim loader\n*/\n\n// Load the informary module into the browser global automatically.\nvar libChoreographic = require('./Choreographic.js');\n\nif (typeof(window) === 'object')\n    window.Choreographic = libChoreographic;\n\nmodule.exports = libChoreographic;","// A simple host for managing scripts with isolated data outputs each run automatically\n// both on the development box as well as in production if necessary.\n\n// If we want to load a configuration file, just set this property in pConfiguration:\n// ConfigFile:`${__dirname}/Extra-Configuration.json`,\n\n/*\n * This will have some run-specific data in settings:\n *\n * (DataFolder is where the data goes)\n\n {\n\t\"App\":\n\t{\n\t\t\"Hash\": \"Script\",\n\t\t\"RunID\": \"Script-Run-2022-08-12-15-35-01-21-859\",\n\t\t\"DataRoot\": \"/some/folderlike/container/for/rundata/\",\n\t\t\"DataFolder\": \"/some/folderlike/container/for/rundata/Script-Run-2022-08-12-15-35-01-21-859/\"\n\t}\n }\n\n */\n\nconst libFS = require('fs');\n\n// This expects either a config object or a string that points to a file.\nclass Choreographic\n{\n\tconstructor(pConfiguration)\n\t{\n\t\tthis._InitialConfiguration = (typeof(pConfiguration) == 'object') ? pConfiguration : {};\n\t\tthis._InitialConfigurationFile = {};\n\n\t\tthis._Dependencies = (\n\t\t\t{\n\t\t\t\tfs: libFS\n\t\t\t});\n\n\t\tif (typeof(pConfiguration) == 'string')\n\t\t{\n\t\t\tthis.loadInitialConfigurationFile(pConfiguration);\n\t\t}\n\t\telse if ((this._InitialConfiguration.hasOwnProperty('ConfigFile')))\n\t\t{\n\t\t\t// We are going to manually override the Fable auto-config loading\n\t\t\t// So we can generate extra elements regarding the run-specific folders\n\t\t\tthis.loadInitialConfigurationFile(this._InitialConfiguration.ConfigFile);\n\t\t}\n\n\t\tthis.settings = null;\n\n\t\t// Timestamps will just be the long ints\n\t\tthis.timeStamps = {};\n\t\t// ProgressTrackers have an object format of: {Hash:'SomeHash',EndTime:UINT,CurrentTime:UINT,TotalCount:INT,CurrentCount:INT}\n\t\tthis.progressTrackers = {};\n\n\t\tthis.initializeSettingsObject();\n\n\t\tthis.initializeRunSpecificData();\n\t}\n\n\t/************************************************************************\n\t * BEGINNING OF -->  Script Initialization Functions\n\t */\n\tloadInitialConfigurationFile(pConfigurationFile)\n\t{\n\t\tif (typeof(pConfigurationFile) == 'string')\n\t\t{\n\t\t\t// Try to load the config file.\n\t\t\ttry\n\t\t\t{\n\t\t\t\tthis._InitialConfigurationFile = require(pConfigurationFile);\n\t\t\t\tconsole.log(`Loaded configuration file [${pConfigurationFile}].`)\n\t\t\t}\n\t\t\tcatch (pConfigFileLoadException)\n\t\t\t{\n\t\t\t\tthis._InitialConfigurationFile = {};\n\t\t\t\tconsole.log(`Error attempting to load configuration file [${pConfigurationFile}]: ${pConfigFileLoadException}`);\n\t\t\t}\n\t\t}\n\t}\n\n\tinitializeSettingsObject()\n\t{\n\t\t// Merge the file and the passed-in config.\n\t\t// The passed-in config takes precedence in this spread merge operation.\n\t\tthis.settings = { ...this._InitialConfigurationFile, ...this._InitialConfiguration};\n\t}\n\n\tinitializeRunSpecificData()\n\t{\n\t\t// Make sure the app-specific and run-specific object is available.\n\t\tif (!this.settings.hasOwnProperty('App'))\n\t\t{\n\t\t\tthis.settings.App = {};\n\t\t}\n\t\telse if (typeof(this.settings.App) != 'object')\n\t\t{\n\t\t\t// If the App settings thing isn't an object, this is all going to be really challenging.\n\t\t\tconsole.log(`Settings object has an \"App\" property but it is not an object, it is of type ${typeof(this.settings.App)} with a value of [${this.settings.App}].  Moving this property to the \"__ERROR_App\" property.`);\n\t\t\tthis.settings._ERROR_App = this.settings.App;\n\t\t\tthis.settings.App = {};\n\t\t}\n\n\t\tif (!this.settings.App.hasOwnProperty('Hash'))\n\t\t{\n\t\t\t// TODO: Potentially pull the App Name from the config.\n\t\t\tthis.settings.App.Hash = 'ScriptHost';\n\t\t}\n\t\tif (!this.settings.hasOwnProperty('Product'))\n\t\t{\n\t\t\tthis.settings.Product = this.settings.App.Hash;\n\t\t}\n\t\tif (!this.settings.hasOwnProperty('ProductVersion'))\n\t\t{\n\t\t\tthis.settings.ProductVersion = '0.0.0';\n\t\t}\n\n\t\t// Check to see if a folder in the settings for the unique per-run folders.\n\t\t// Note this is the \"data root\" folder, meaning each time you run the script\n\t\t//     a folder will be created in here with a timestamp with logs and data\n\t\t//     from the run.\n\t\t// By default create a \"rundata\" folder in the same place as the code file.\n\t\tif (!this.settings.App.hasOwnProperty('DataRoot'))\n\t\t{\n\t\t\tthis.settings.App.DataRoot = `${process.cwd()}/rundata/`;\n\t\t}\n\n\t\t// Now create the root folder for the rundata.\n\t\t// TODO: Change this to recursive dropbag folder create functions\n\t\tif (!libFS.existsSync(this.settings.App.DataRoot))\n\t\t{\n\t\t\tlibFS.mkdirSync(this.settings.App.DataRoot);\n\t\t}\n\n\t\t// Create a specific run folder (for caching files, output and a log) based on time\n\t\tthis.settings.App.RunTimeStart = new Date();\n\t\t// Small macro to return a 2 digit number that is zero filled on the left\n\t\t// TODO: Tested simple library for data processing as such\n\t\tlet formatDateString = (pDateValue) => { return (`00${pDateValue}`).slice(-2); };\n\n\t\t// Create a unique run hash for this specific run\n\t\tthis.settings.App.RunID = `${this.settings.App.Hash}-Run-${this.settings.App.RunTimeStart.getFullYear()}-${formatDateString(this.settings.App.RunTimeStart.getMonth()+1)}-${formatDateString(this.settings.App.RunTimeStart.getDate())}-${formatDateString(this.settings.App.RunTimeStart.getHours())}-${formatDateString(this.settings.App.RunTimeStart.getMinutes())}-${formatDateString(this.settings.App.RunTimeStart.getSeconds())}-${this.settings.App.RunTimeStart.getMilliseconds()}`;\n\t\tthis.settings.App.DataFolder = `${this.settings.App.DataRoot}${this.settings.App.RunID}`;\n\n\t\t// Now create the run specific data folder\n\t\tlibFS.mkdirSync(this.settings.App.DataFolder);\n\n\t\t// Check to see if there is a log streams object, or create one if there isn't.\n\t\tif (!this.settings.hasOwnProperty('LogStreams'))\n\t\t{\n\t\t\tthis.settings.LogStreams = [];\n\t\t}\n\t\t// Add a log file for this run, in the run specific data folder.\n\t\tthis.settings.LogStreams.push(\n\t\t\t// Because the simpleflatfile log stream writes to console and file, we are good!\n\t\t\t{\n\t\t\t\t\"level\": \"trace\",\n\t\t\t\t\"streamtype\": \"simpleflatfile\",\n\t\t\t\t\"path\": `${this.settings.App.DataFolder}/${this.settings.App.RunID}.log`\n\t\t\t});\n\n\t\tthis.fable = require('fable').new(this.settings);\n\n\t\tthis.log = this.fable.log;\n\n\t\tthis.log.info(`Starting up script host [${this.settings.App.DataFolder}/${this.settings.App.RunID}.log] for ${this.settings.App.Hash}...`);\n\t}\n\t/*\n\t * END OF       -->  Script Initialization Functions\n\t ************************************************************************/\n\n\n\n\t/************************************************************************\n\t * BEGINNING OF -->  Logging and Telemetry Helpers\n\t */\n\tcreateTimeStamp(pTimeStampHash)\n\t{\n\t\tlet tmpTimeStampHash = (typeof(pTimeStampHash) == 'string') ? pTimeStampHash : 'Default';\n\t\tthis.timeStamps[tmpTimeStampHash] = +new Date();\n\t\treturn this.timeStamps[tmpTimeStampHash];\n\t}\n\n\tgetTimeDelta(pTimeStampHash)\n\t{\n\t\tlet tmpTimeStampHash = (typeof(pTimeStampHash) == 'string') ? pTimeStampHash : 'Default';\n\t\tif (this.timeStamps.hasOwnProperty(tmpTimeStampHash))\n\t\t{\n\t\t\tlet tmpEndTime = +new Date();\n\t\t\treturn tmpEndTime-this.timeStamps[tmpTimeStampHash];\t\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tlogTimeDelta(pTimeStampHash, pMessage)\n\t{\n\t\tlet tmpTimeStampHash = (typeof(pTimeStampHash) == 'string') ? pTimeStampHash : 'Default';\n\t\tlet tmpMessage = (typeof(pMessage) !== 'undefined') ? pMessage : `Elapsed for ${tmpTimeStampHash}: `;\n\t\tlet tmpOperationTime = this.getTimeDelta(pTimeStampHash);\n\t\tthis.info(tmpMessage +' ('+tmpOperationTime+'ms)');\n\t\treturn tmpOperationTime;\n\t}\n\n\tcreateProgressTracker(pTotalOperations, pProgressTrackerHash)\n\t{\n\t\tlet tmpProgressTrackerHash = (typeof(pProgressTrackerHash) == 'string') ? pProgressTrackerHash : 'DefaultProgressTracker';\n\t\tlet tmpTotalOperations = (typeof(pTotalOperations) == 'number') ? pTotalOperations : 100;\n\n\t\tlet tmpProgressTracker = (\n\t\t\t{\n\t\t\t\tHash: tmpProgressTrackerHash,\n\t\t\t\tStartTime: this.createTimeStamp(tmpProgressTrackerHash),\n\t\t\t\tEndTime: 0,\n\t\t\t\tCurrentTime: 0,\n\t\t\t\tPercentComplete: -1,\n\t\t\t\tAverageOperationTime: -1,\n\t\t\t\tEstimatedCompletionTime: -1,\n\t\t\t\tTotalCount: tmpTotalOperations,\n\t\t\t\tCurrentCount:-1\n\t\t\t});\n\n\t\tthis.progressTrackers[tmpProgressTrackerHash] = tmpProgressTracker;\n\n\t\treturn tmpProgressTracker;\n\t}\n\n\tsolveProgressTrackerStatus(pProgressTrackerHash)\n\t{\n\t\tlet tmpProgressTrackerHash = (typeof(pProgressTrackerHash) == 'string') ? pProgressTrackerHash : 'DefaultProgressTracker';\n\n\t\tif (!this.progressTrackers.hasOwnProperty(tmpProgressTrackerHash))\n\t\t{\n\t\t\tthis.createProgressTracker(100, tmpProgressTrackerHash);\n\t\t}\n\n\t\tlet tmpProgressTracker = this.progressTrackers[tmpProgressTrackerHash];\n\n\t\ttmpProgressTracker.CurrentTime = this.getTimeDelta(tmpProgressTracker.Hash);\n\n\t\tif ((tmpProgressTracker.CurrentCount > 0) && (tmpProgressTracker.TotalCount > 0))\n\t\t{\n\t\t\ttmpProgressTracker.PercentComplete = (tmpProgressTracker.CurrentCount / tmpProgressTracker.TotalCount) * 100.0;\n\t\t}\n\n\t\tif ((tmpProgressTracker.CurrentCount > 0) && (tmpProgressTracker.CurrentTime > 0))\n\t\t{\n\t\t\ttmpProgressTracker.AverageOperationTime = tmpProgressTracker.CurrentTime / tmpProgressTracker.CurrentCount;\n\t\t}\n\n\t\tif ((tmpProgressTracker.CurrentCount < tmpProgressTracker.TotalCount) && (tmpProgressTracker.AverageOperationTime > 0))\n\t\t{\n\t\t\ttmpProgressTracker.EstimatedCompletionTime = (tmpProgressTracker.TotalCount - tmpProgressTracker.CurrentCount) * tmpProgressTracker.AverageOperationTime;\n\t\t}\n\t}\n\n\tupdateProgressTrackerStatus(pProgressTrackerHash, pCurrentOperations)\n\t{\n\t\tlet tmpProgressTrackerHash = (typeof(pProgressTrackerHash) == 'string') ? pProgressTrackerHash : 'DefaultProgressTracker';\n\t\tlet tmpCurrentOperations = parseInt(pCurrentOperations);\n\n\t\tif (isNaN(tmpCurrentOperations))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!this.progressTrackers.hasOwnProperty(tmpProgressTrackerHash))\n\t\t{\n\t\t\tthis.createProgressTracker(100, tmpProgressTrackerHash);\n\t\t}\n\n\t\tthis.progressTrackers[tmpProgressTrackerHash].CurrentCount = tmpCurrentOperations;\n\t\tthis.progressTrackers[tmpProgressTrackerHash].CurrentTime = this.getTimeDelta(tmpProgressTrackerHash);\n\n\t\tthis.solveProgressTrackerStatus(tmpProgressTrackerHash);\n\n\t\treturn this.progressTrackers[tmpProgressTrackerHash];\n\t}\n\n\tincrementProgressTrackerStatus(pProgressTrackerHash, pIncrementSize)\n\t{\n\t\tlet tmpProgressTrackerHash = (typeof(pProgressTrackerHash) == 'string') ? pProgressTrackerHash : 'DefaultProgressTracker';\n\t\tlet tmpIncrementSize = parseInt(pIncrementSize);\n\n\t\tif (isNaN(tmpIncrementSize))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!this.progressTrackers.hasOwnProperty(tmpProgressTrackerHash))\n\t\t{\n\t\t\tthis.createProgressTracker(100, tmpProgressTrackerHash);\n\t\t}\n\n\t\tthis.progressTrackers[tmpProgressTrackerHash].CurrentCount = this.progressTrackers[tmpProgressTrackerHash].CurrentCount + tmpIncrementSize;\n\t\tthis.progressTrackers[tmpProgressTrackerHash].CurrentTime = this.getTimeDelta(tmpProgressTrackerHash);\n\n\t\tthis.solveProgressTrackerStatus(tmpProgressTrackerHash);\n\n\t\treturn this.progressTrackers[tmpProgressTrackerHash];\n\t}\n\n\tsetProgressTrackerEndTime(pProgressTrackerHash, pCurrentOperations)\n\t{\n\t\tlet tmpProgressTrackerHash = (typeof(pProgressTrackerHash) == 'string') ? pProgressTrackerHash : 'DefaultProgressTracker';\n\t\tlet tmpCurrentOperations = parseInt(pCurrentOperations);\n\n\t\tif (!this.progressTrackers.hasOwnProperty(tmpProgressTrackerHash))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (!isNaN(tmpCurrentOperations))\n\t\t{\n\t\t\tthis.updateProgressTrackerStatus(tmpProgressTrackerHash, tmpCurrentOperations);\n\t\t}\n\n\t\tthis.progressTrackers[tmpProgressTrackerHash].EndTime = this.getTimeDelta(tmpProgressTrackerHash);\n\t\t\n\t\tthis.solveProgressTrackerStatus(tmpProgressTrackerHash);\n\n\t\treturn this.progressTrackers[tmpProgressTrackerHash];\n\t}\n\n\tprintProgressTrackerStatus(pProgressTrackerHash)\n\t{\n\t\tlet tmpProgressTrackerHash = (typeof(pProgressTrackerHash) == 'string') ? pProgressTrackerHash : 'DefaultProgressTracker';\n\t\t\n\t\tif (!this.progressTrackers.hasOwnProperty(tmpProgressTrackerHash))\n\t\t{\n\t\t\tthis.log.info(`>> Progress Tracker ${tmpProgressTrackerHash} does not exist!  No stats to display.`);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tconst tmpProgressTracker = this.progressTrackers[tmpProgressTrackerHash];\n\n\t\t\tif (tmpProgressTracker.CurrentCount < 1)\n\t\t\t{\n\t\t\t\tthis.log.info(`>> Progress Tracker ${tmpProgressTracker.Hash} has no completed operations.  ${tmpProgressTracker.CurrentTime}ms have elapsed since it was started.`);\n\t\t\t}\n\t\t\telse if (tmpProgressTracker.EndTime < 1)\n\t\t\t{\n\t\t\t\tthis.log.info(`>> Progress Tracker ${tmpProgressTracker.Hash} is ${tmpProgressTracker.PercentComplete.toFixed(3)}% completed - ${tmpProgressTracker.CurrentCount} / ${tmpProgressTracker.TotalCount} operations over ${tmpProgressTracker.CurrentTime}ms (median ${tmpProgressTracker.AverageOperationTime.toFixed(3)} per).  Estimated completion in ${tmpProgressTracker.EstimatedCompletionTime.toFixed(0)}ms or ${(tmpProgressTracker.EstimatedCompletionTime / 1000 / 60).toFixed(2)}minutes`)\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.log.info(`>> Progress Tracker ${tmpProgressTracker.Hash} is done and completed ${tmpProgressTracker.CurrentCount} / ${tmpProgressTracker.TotalCount} operations in ${tmpProgressTracker.EndTime}ms.`)\n\t\t\t}\n\t\t}\n\t}\n\n\tlogMemoryResourcesUsed()\n\t{\n\n\t\tconst tmpResourcesUsed = process.memoryUsage().heapUsed / 1024 / 1024;\n\t\tthis.log.info(`Memory usage at ${Math.round(tmpResourcesUsed * 100) / 100} MB`);\t\t\n\t}\n\t/*\n\t * END OF       -->  Logging and Telemetry Helpers\n\t ************************************************************************/\n\n\n\n\t/************************************************************************\n\t * BEGINNING OF -->  Script File Persistence Helpers\n\t */\n\twriteFileToRunDataFolderFromObjectSync(pFileName, pObject)\n\t{\n\t\tlibFS.writeFileSync(`${this.settings.App.DataFolder}/${pFileName}`, JSON.stringify(pObject, null, 4), 'utf8');\n\t}\n\n\twriteFileToRunDataFolderSync(pFileName, pFileContent)\n\t{\n\t\tlibFS.writeFileSync(`${this.settings.App.DataFolder}/${pFileName}`,pFileContent,'utf8');\t\t\n\t}\n\n\twriteTextFileFromArray(pFileName, pFileArray)\n\t{\n\t\tif (!Array.isArray(pFileArray))\n\t\t{\n\t\t\tthis.log.error(`Attempted to write ${pFileName} but the expected array was not an array.`);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlet tmpOutCSVFile = `${this.settings.App.DataFolder}/${pFileName}`;\n\t\t\tfor (let i = 0; i < pFileArray.length; i++)\n\t\t\t{\n\t\t\t\tlibFS.appendFileSync(tmpOutCSVFile, pFileArray[i]+\"\\n\", 'utf8');\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\t * END OF       -->  Script File Persistence Helpers\n\t ************************************************************************/\n\n\n\n\t/************************************************************************\n\t * BEGINNING OF -->  Object Enumeration Helpers\n\t */\n\t// fProcessFunction has the following signature:\n\t// (pObjectKey, pObject, pScriptHost, fOperationComplete)\n\tenumerateObjectProperties(pObject, fProcessFunction, fEnumerationComplete, pParallelOperations)\n\t{\n\t\tlet tmpParallelOperations = (typeof(pParallelOperations) == 'number') ? pParallelOperations : 1;\n\t\tlet tmpObjectPropertyKeys = Object.keys(pObject);\n\t\tlet tmpfEnumerationComplete = (typeof(fEnumerationComplete) == 'function') ? fEnumerationComplete : ()=>{};\n\n\t\tlibAsync.eachLimit(tmpObjectPropertyKeys, tmpParallelOperations,\n\t\t\t(tmpKey, fOperationComplete) =>\n\t\t\t{\n\t\t\t\treturn fProcessFunction(tmpKey, pObject[tmpKey], this, fOperationComplete);\n\t\t\t}, tmpfEnumerationComplete);\n\t}\n\n\tenumerateArrayEntries(pArray, fProcessFunction, fEnumerationComplete, pParallelOperations)\n\t{\n\t\tlet tmpParallelOperations = (typeof(pParallelOperations) == 'number') ? pParallelOperations : 1;\n\t\tlet tmpfEnumerationComplete = (typeof(fEnumerationComplete) == 'function') ? fEnumerationComplete : ()=>{};\n\n\t\tlibAsync.eachLimit(pArray, tmpParallelOperations,\n\t\t\t(tmpEntry, fOperationComplete) =>\n\t\t\t{\n\t\t\t\treturn fProcessFunction(tmpKey, tmpEntry, this, fOperationComplete);\n\t\t\t}, tmpfEnumerationComplete);\n\t}\n\t/*\n\t * END OF       -->  Object Enumeration Helpers\n\t ************************************************************************/\n}\n\nmodule.exports = Choreographic;\n"]}